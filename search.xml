<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>网络编程</title>
      <link href="/post/f6491cfb.html"/>
      <url>/post/f6491cfb.html</url>
      
        <content type="html"><![CDATA[<p>网络编程是指通过计算机网络实现程序之间的通信和数据交换。网络协议，在网络数据传输中，都遵循的执行规则。人们按照分工的不同把互联网协议从逻辑上划分层：<code>OSI</code>七层或<code>TCP/IP</code>五层或<code>TCP/IP</code>四层。</p><p>OSI只是存在于概念和理论上的一种模型，它的缺点是分层太多，增加了网络工作的复杂性，所以没有大规模应用。后来人们对OSI进行了简化，合并了一些层，最终只保留了4层，从下到上分别是接口层、网络层、传输层和应用层，这就是大名鼎鼎的TCP&#x2F;IP模型。</p><ul><li>网络接口层： 这一层负责在物理网络上传输数据帧。</li><li>网络层： 网络层负责数据包的寻址和路由，以便在不同的网络间进行通信。它使用IP地址来唯一标识网络上的设备，并通过路由选择最佳路径来传输数据。</li><li>传输层： 传输层主要提供端到端的通信，保证数据的可靠传输。TCP和UDP是传输层的两个主要协议。TCP提供可靠的、面向连接的通信，而UDP则是无连接的。</li><li>应用层： 应用层包含了各种网络应用协议，如HTTP、FTP、SMTP等。它提供了一种接口，使应用程序能够通过网络进行通信。在这一层，用户可以使用各种应用软件进行数据传输。</li></ul><h2 id="IP地址"><a href="#IP地址" class="headerlink" title="IP地址"></a>IP地址</h2><p>IP地址（Internet Protocol Address）是分配给网络中的设备以标识和定位它们的数字标签。IP地址是在互联网上进行数据通信时用于唯一标识设备的基本元素。IPv4和 IPv6是目前主要使用的两个 IP 地址版本。</p><p>IPv4地址是一个由32位二进制数字组成的地址，通常以点分十进制表示，形如xxx.xxx.xxx.xxx，其中每个”xxx”代表8位的二进制数，取值范围为0到 255。IPv4地址的总数量为 2^32，即约 42 亿个。</p><p>IPv6地址是一个由128位二进制数字组成的地址，通常以冒号分隔的十六进制表示。IPv6地址的总数量为2^128，远远大于IPv4地址的数量。</p><p>公有IP地址： 公有 IP 地址是全球唯一的，可直接在互联网上进行标识。用于标识网络中的路由器、服务器等设备。</p><p>私有IP地址： 私有 IP 地址用于内部网络，不直接在互联网上可达。内部网络可以使用相同的私有 IP 地址，因为它们通常通过网络地址转换（NAT）来与互联网通信。</p><h2 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h2><p>端口号是计算机中用于标识应用程序的逻辑地址。在网络通信中，数据通过 IP 地址找到目标设备后，通过端口号找到目标设备上的具体应用程序。<br>在TCP&#x2F;IP模型中，端口号用于标识主机上的特定应用程序。它是一个16位的整数，范围从0到65535。端口号分为两类：</p><ul><li>熟知端口：范围从0到1023，用于标识一些常见的服务，例如HTTP（端口号80）、FTP（端口号21）、SSH（端口号22）等。</li><li>注册端口： 范围从1024到65535，是为用户进程或应用程序分配的端口号。这些端口号不像熟知端口那样标准化，但可以由软件开发人员和系统管理员选择，以确保不同的应用程序不会冲突。IANA也负责维护这个范围内的端口号。</li></ul><h2 id="套接字socket"><a href="#套接字socket" class="headerlink" title="套接字socket"></a>套接字socket</h2><p>套接字(Socket)：socket的原意是“插座”，在计算机通信领域，socket 被翻译为“套接字”， 是实现网络编程进行数据传输的一种技术手段，网络上各种各样的网络服务大多都是基于Socket来完成通信的。</p><p>Socket是应用层与TCP&#x2F;IP协议族通信的中间软件抽象层，它是一组接口。它把复杂的TCP&#x2F;IP协议族隐藏在Socket接口后面，我们无需深入理解tcp&#x2F;udp协议，socket已经为我们封装好了，我们只需要遵循socket的规定去编程。</p><h2 id="Socket代码书写"><a href="#Socket代码书写" class="headerlink" title="Socket代码书写"></a>Socket代码书写</h2><p><strong>服务端代码</strong></p><ul><li><p>导入Python套接字编程模块：import socket</p></li><li><p>创建套接字</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能：创建套接字</span></span><br><span class="line"><span class="string">参数：socket_family  网络地址类型 AF_INET表示ipv4</span></span><br><span class="line"><span class="string"> socket_type  套接字类型 SOCK_STREAM 表示tcp套接字 （也叫流式套接字）</span></span><br><span class="line"><span class="string">返回值： 套接字对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sockfd = socket.socket(socket_family,socket_type)</span><br></pre></td></tr></table></figure></li><li><p>绑定地址</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能：绑定本机网络地址</span></span><br><span class="line"><span class="string">参数：元组 (ip,port)  (&#x27;127.0.0.1&#x27;,8888)</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sockfd.bind(addr)</span><br></pre></td></tr></table></figure></li><li><p>设置监听</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能：将套接字设置为监听套接字，确定监听队列大小</span></span><br><span class="line"><span class="string">参数：监听队列大小</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sockfd.listen(n)</span><br></pre></td></tr></table></figure></li><li><p>处理客户端连接请求</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能：阻塞等待处理客户端请求</span></span><br><span class="line"><span class="string">返回值：connfd  客户端连接套接字  addr  连接的客户端地址</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">connfd,addr = sockfd.accept()</span><br></pre></td></tr></table></figure></li><li><p>消息收发</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能: 接受客户端消息</span></span><br><span class="line"><span class="string">参数：每次最多接收消息的大小</span></span><br><span class="line"><span class="string">返回值：接收到的内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data = connfd.recv(size)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能 : 发送消息</span></span><br><span class="line"><span class="string">参数 ：要发送的内容  bytes格式</span></span><br><span class="line"><span class="string">返回值： 发送的字节数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">n = connfd.send(data)</span><br></pre></td></tr></table></figure></li><li><p>关闭套接字</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 功能：关闭套接字</span></span><br><span class="line">sockfd.close()</span><br></pre></td></tr></table></figure></li></ul><p><strong>客户端代码</strong></p><ul><li><p>导入Python套接字编程模块：import socket</p></li><li><p>创建套接字</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能：创建套接字</span></span><br><span class="line"><span class="string">参数：socket_family  网络地址类型 AF_INET表示ipv4</span></span><br><span class="line"><span class="string"> socket_type  套接字类型 SOCK_STREAM 表示tcp套接字 （也叫流式套接字）</span></span><br><span class="line"><span class="string">返回值： 套接字对象</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sockfd = socket.socket(socket_family,socket_type)</span><br></pre></td></tr></table></figure></li><li><p>请求连接</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能：连接服务器</span></span><br><span class="line"><span class="string">参数：元组 服务器地址</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">sockfd.connect(server_addr)</span><br></pre></td></tr></table></figure></li><li><p>收发消息</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能: 接受客户端消息</span></span><br><span class="line"><span class="string">参数：每次最多接收消息的大小</span></span><br><span class="line"><span class="string">返回值：接收到的内容</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">data = connfd.recv(size)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">功能 : 发送消息</span></span><br><span class="line"><span class="string">参数 ：要发送的内容  bytes格式</span></span><br><span class="line"><span class="string">返回值： 发送的字节数</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">n = connfd.send(data)</span><br><span class="line"></span><br></pre></td></tr></table></figure><blockquote><p>注意： 防止两端都阻塞，recv send要配合</p></blockquote></li><li><p>关闭套接字</p></li></ul><h2 id="粘包问题"><a href="#粘包问题" class="headerlink" title="粘包问题"></a>粘包问题</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8001</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line">conn, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">client_data = conn.recv(<span class="number">1024</span>)</span><br><span class="line"><span class="built_in">print</span>(client_data.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8001</span>))</span><br><span class="line"></span><br><span class="line">client.send(<span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line">client.send(<span class="string">&#x27; world&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure><p>解决粘包的问题</p><ul><li><p>每次发送的消息时，都将消息划分为 头部（固定字节长度） 和 数据 两部分。例如：头部，用4个字节表示后面数据的长度。</p><ul><li>发送数据，先发送数据的长度，再发送数据（或拼接起来再发送）。</li><li>接收数据，先读4个字节就可以知道自己这个数据包中的数据长度，再根据长度读取到数据。</li></ul></li><li><p>对于头部需要一个数字并固定为4个字节，这个功能可以借助python的struct模块来实现</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> struct</span><br><span class="line">v1 = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="number">199</span>)</span><br><span class="line"></span><br><span class="line">v2 = struct.unpack(<span class="string">&#x27;i&#x27;</span>, v1)</span><br><span class="line"><span class="built_in">print</span>(v2)</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)</span><br><span class="line">sock.bind((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8001</span>))</span><br><span class="line">sock.listen(<span class="number">5</span>)</span><br><span class="line">conn, addr = sock.accept()</span><br><span class="line"></span><br><span class="line">header1 = conn.recv(<span class="number">4</span>)</span><br><span class="line">data_length1 = struct.unpack(<span class="string">&#x27;i&#x27;</span>, header1)[<span class="number">0</span>]</span><br><span class="line">has_recv_len = <span class="number">0</span></span><br><span class="line">data1 = <span class="string">b&quot;&quot;</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    length = data_length1 - has_recv_len</span><br><span class="line">    <span class="keyword">if</span> length &gt; <span class="number">1024</span>:</span><br><span class="line">        lth = <span class="number">1024</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">        lth = length</span><br><span class="line">chunk = conn.recv(lth) </span><br><span class="line">    data1 += chunk</span><br><span class="line">    has_recv_len += <span class="built_in">len</span>(chunk)</span><br><span class="line">    <span class="keyword">if</span> has_recv_len == data_length1:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="built_in">print</span>(data1.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">header2 = conn.recv(<span class="number">4</span>)</span><br><span class="line">data_length2 = struct.unpack(<span class="string">&#x27;i&#x27;</span>, header2)[<span class="number">0</span>] </span><br><span class="line">data2 = conn.recv(data_length2) </span><br><span class="line"><span class="built_in">print</span>(data2.decode(<span class="string">&#x27;utf-8&#x27;</span>))</span><br><span class="line"></span><br><span class="line">conn.close()</span><br><span class="line">sock.close()</span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> socket</span><br><span class="line"><span class="keyword">import</span> struct</span><br><span class="line"></span><br><span class="line">client = socket.socket()</span><br><span class="line">client.connect((<span class="string">&#x27;127.0.0.1&#x27;</span>, <span class="number">8001</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data1 = <span class="string">&#x27;hello&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">header1 = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(data1))</span><br><span class="line">client.send(header1)</span><br><span class="line">client.send(data1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">data2 = <span class="string">&#x27; world&#x27;</span>.encode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">header2 = struct.pack(<span class="string">&#x27;i&#x27;</span>, <span class="built_in">len</span>(data2))</span><br><span class="line">client.send(header2)</span><br><span class="line">client.send(data2)</span><br><span class="line"></span><br><span class="line">client.close()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异常处理</title>
      <link href="/post/28877bf.html"/>
      <url>/post/28877bf.html</url>
      
        <content type="html"><![CDATA[<p>开发人员在编写程序时，难免会遇到错误，有的是编写人员疏忽造成的语法错误，有的是程序内部隐含逻辑问题造成的数据错误，还有的是程序运行时与系统的规则冲突造成的系统错误。编写程序时遇到的错误可大致分为 2 类，分别为语法错误和运行时错误。</p><h2 id="Python语法错误"><a href="#Python语法错误" class="headerlink" title="Python语法错误"></a>Python语法错误</h2><p>语法错误，也就是解析代码时出现的错误。当代码不符合Python语法规则时，Python解释器在解析时就会报出SyntaxError语法错误，与此同时还会明确指出最早探测到错误的语句。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello,World!&quot;</span></span><br></pre></td></tr></table></figure><p>解释器会报如下错误：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: Missing parentheses in call to &#x27;print&#x27;</span><br></pre></td></tr></table></figure><p>这种错误应该在程序运行前就修改正确</p><h2 id="Python运行时错误"><a href="#Python运行时错误" class="headerlink" title="Python运行时错误"></a>Python运行时错误</h2><p>运行时错误，即程序在语法上都是正确的，但在运行时发生了错误。常见异常类型</p><table><thead><tr><th align="center">异常类型</th><th align="center">含义</th></tr></thead><tbody><tr><td align="center">AttributeError</td><td align="center">当试图访问的对象属性不存在时抛出的异常</td></tr><tr><td align="center">IndexError</td><td align="center">索引超出序列范围会引发此异常</td></tr><tr><td align="center">KeyError</td><td align="center">字典中查找一个不存在的关键字时引发此异常</td></tr><tr><td align="center">NameError</td><td align="center">尝试访问一个未声明的变量时，引发此异常</td></tr><tr><td align="center">TypeError</td><td align="center">不同类型数据之间的无效操作</td></tr></tbody></table><p>当一个程序发生异常时，代表该程序在执行时出现了非正常的情况，无法再执行下去。默认情况下，程序是要终止的。如果要避免程序退出，可以使用捕获异常的方式获取这个异常的名称，再通过其他的逻辑代码让程序继续运行，这种根据异常做出的逻辑处理叫作异常处理。</p><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> 异常类型：</span><br><span class="line">    检测到异常，就执行这个位置的逻辑</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;start...&#x27;</span>)</span><br><span class="line">    <span class="built_in">print</span>(x)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;end...&#x27;</span>)</span><br><span class="line"><span class="comment"># as语法将异常类型的值赋值给变量e，这样我们通过打印e便可以知道错误的原因</span></span><br><span class="line"><span class="keyword">except</span> NameError <span class="keyword">as</span> e: </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;异常值为：%s&#x27;</span> %e)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;run other code...&#x27;</span>)</span><br></pre></td></tr></table></figure><p>如果我们想分别用不同的逻辑处理，需要用到多分支的except（类似于多分支的elif，从上到下依次匹配，匹配成功一次便不再匹配其他）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    触发NameError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    触发IndexError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> KeyError:</span><br><span class="line">    触发KeyError时对应的处理逻辑</span><br></pre></td></tr></table></figure><p>如果我们想捕获所有异常并用一种逻辑处理，Python提供了一个万能异常类型Exception</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> NameError:</span><br><span class="line">    触发NameError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> IndexError:</span><br><span class="line">    触发IndexError时对应的处理逻辑</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    其他类型的异常统一用此处的逻辑处理</span><br></pre></td></tr></table></figure><p>在多分支except之后还可以跟一个else（else必须跟在except之后，不能单独存在），只有在被检测的代码块没有触发任何异常的情况下才会执行else的子代码块</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    被检测的代码块</span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">1</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">2</span>:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">......</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    没有异常发生时执行的代码块</span><br></pre></td></tr></table></figure><p>此外try还可以与finally连用可以使用try-except-finally的形式，也可以直接使用try-finally的形式。无论被检测的代码块是否触发异常，都会执行finally的子代码块，因此通常在finally的子代码块做一些回收资源的操作，比如关闭打开的文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>: </span><br><span class="line">    被检测的代码块 </span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">1</span>: </span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line"><span class="keyword">except</span> 异常类型<span class="number">2</span>: </span><br><span class="line">    <span class="keyword">pass</span> </span><br><span class="line">...... </span><br><span class="line"><span class="keyword">else</span>: </span><br><span class="line">    没有异常发生时执行的代码块 </span><br><span class="line"><span class="keyword">finally</span>: </span><br><span class="line">    无论有无异常发生都会执行的代码块</span><br></pre></td></tr></table></figure><p>在不符合Python解释器的语法或逻辑规则时，是由Python解释器主动触发的各种类型的异常，而对于违反程序员自定制的各类规则，则需要由程序员自己来明确地触发异常，这就用到了raise语句，raise后必须是一个异常的类或者是异常的实例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> TypeError(<span class="string">&#x27;name must be str&#x27;</span>)</span><br></pre></td></tr></table></figure><p>我们可以通过继承内置的异常类来自定义异常类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyException</span>(<span class="title class_ inherited__">BaseException</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,msg</span>):</span><br><span class="line">        self.msg=msg</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.msg</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">raise</span> MyException(<span class="string">&#x27;类型错误&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> MyException <span class="keyword">as</span> e:</span><br><span class="line">    <span class="built_in">print</span>(e)</span><br></pre></td></tr></table></figure><h2 id="断言"><a href="#断言" class="headerlink" title="断言"></a>断言</h2><p>Python assert语句，又称断言语句，可以看做是功能缩小版的if语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python解释器会报 AssertionError 错误。</p><p>assert会令程序崩溃，为什么还要使用它呢？这是因为，与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃，这有利于我们对程序排错，提高程序的健壮性。因此，assert 语句通常用于检查用户的输入是否符合规定，还经常用作程序初期测试和调试过程中的辅助工具。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">mathmark = <span class="built_in">int</span>(<span class="built_in">input</span>())</span><br><span class="line"><span class="comment"># 断言数学考试分数是否位于正常范围内</span></span><br><span class="line"><span class="keyword">assert</span> <span class="number">0</span> &lt;= mathmark &lt;= <span class="number">100</span></span><br><span class="line"><span class="comment"># 只有当 mathmark 位于 [0,100]范围内，程序才会继续执行</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;数学考试分数为：&quot;</span>,mathmark)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面向对象</title>
      <link href="/post/28239a8d.html"/>
      <url>/post/28239a8d.html</url>
      
        <content type="html"><![CDATA[<p>面向对象（Object-Oriented，简称OO）是一种编程范式，编程范式是一种编程方法论。不同的编程范式在解决问题的时候强调不同的思想。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 面向过程风格的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数计算矩形面积</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_rectangle_area</span>(<span class="params">length, width</span>):</span><br><span class="line">    <span class="keyword">return</span> length * width</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义函数计算矩形周长</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">calculate_rectangle_perimeter</span>(<span class="params">length, width</span>):</span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * (length + width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用函数计算矩形的面积和周长</span></span><br><span class="line">length = <span class="number">5</span></span><br><span class="line">width = <span class="number">3</span></span><br><span class="line">area = calculate_rectangle_area(length, width)</span><br><span class="line">perimeter = calculate_rectangle_perimeter(length, width)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;矩形面积：<span class="subst">&#123;area&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;矩形周长：<span class="subst">&#123;perimeter&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>这种方式强调的是对问题进行步骤化的拆分，以及通过函数的调用来实现不同的操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 面向对象风格的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义矩形类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Rectangle</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, length, width</span>):</span><br><span class="line">        self.length = length</span><br><span class="line">        self.width = width</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义方法计算矩形面积</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.length * self.width</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义方法计算矩形周长</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">calculate_perimeter</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="number">2</span> * (self.length + self.width)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建矩形对象</span></span><br><span class="line">rectangle = Rectangle(<span class="number">5</span>, <span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用对象的方法计算矩形的面积和周长</span></span><br><span class="line">area = rectangle.calculate_area()</span><br><span class="line">perimeter = rectangle.calculate_perimeter()</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;矩形面积：<span class="subst">&#123;area&#125;</span>&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;矩形周长：<span class="subst">&#123;perimeter&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p>在面向对象的编程中，我们将数据和操作封装在一个类中。上述代码中，我们定义了一个矩形类，它具有属性length 和 width和方法calculate_area 和calculate_perimeter。通过创建矩形对象，我们可以直接调用对象的方法来实现操作。这种方式强调的是对问题进行对象化的抽象，通过对象之间的交互来解决问题。</p><p>面向对象可以帮助我们从宏观上把握、从整体上分析。 但是，具体到实现部分的微观操作，仍然需要面向过程的思路去处理。我们千万不要把面向过程和面向对象对立起来。他们是相辅相成的。面向对象离不开面向过程。</p><h2 id="类与对象"><a href="#类与对象" class="headerlink" title="类与对象"></a>类与对象</h2><p>类是一个抽象的概念，用于描述具有相似属性和行为的一组对象。它是创建对象的蓝图或模板。</p><p>Python中定义一个类使用class关键字实现，在给类起名字时，建议每个单词的首字母大写，其它字母小写。给类起好名字之后，其后要跟有<strong>冒号：</strong>表示告诉Python解释器，下面要开始设计类的内部功能了。类属性指的就是包含在类中的变量，而类方法指的是包含类中的函数。换句话说，类属性和类方法其实分别是包含在类中的变量和函数的别称。 需要注意的一点是，同属一个类的所有类属性和类方法，要保持统一的缩进格式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">类名</span>：</span><br><span class="line">    <span class="comment"># 多个类属性...</span></span><br><span class="line">    <span class="comment"># 多个类方法...</span></span><br></pre></td></tr></table></figure><p>对象是类的实例，是类的具体个体。通过实例化（创建）类，你可以得到一个对象，这个对象拥有类定义的属性和方法。每个对象都是独一无二的，即使它们属于同一个类，它们的属性值可以不同。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名()</span><br></pre></td></tr></table></figure><p><code>__init__()</code>类构造方法：<br>在创建类时，我们可以手动添加一个 <code>__init__()</code>方法，该方法是一个特殊的类实例方法，称为构造方法。构造方法用于创建对象时使用，每当创建一个类的实例对象时，Python 解释器都会自动调用它。Python 类中，手动添加构造方法的语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self,...</span>):</span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure><p>注意，<code>__init__</code>，开头和结尾各有 2 个下划线，且中间不能有空格。Python 中很多这种以双下划线开头、双下划线结尾的方法，都具有特殊的意义。如果<code>__init__</code>方法有参数的话：在实例化的时候除了self，其他的需要手动传递参数。</p><h2 id="成员"><a href="#成员" class="headerlink" title="成员"></a>成员</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p><strong>实例属性：</strong>在任意类方法内部，以“self.变量名”的方式定义的变量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">对象 = 类名()</span><br><span class="line">对象.属性名 = 值</span><br></pre></td></tr></table></figure><ul><li>通常在构造函数(<code>__init__</code>)中创建。</li><li>每个对象存储一份，通过对象访问。描述某个对象的数据。</li><li>只能通过对象名访问，无法通过类名访问。</li></ul><p><strong>类属性：</strong>在类中，方法外定义变量。  </p><ul><li>存储在类中，只有一份，被所有对象共享。</li><li>类方法的调用方式有 2 种<ul><li>使用类名直接调用</li><li>使用类的实例化对象调用。</li></ul></li></ul><p><strong>局部变量：</strong>类方法中还可以定义局部变量。局部变量直接以“变量名&#x3D;值”的方式进行定义，局部变量只能用于所在函数中。</p><h3 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h3><p><strong>实例方法：</strong>在类中定义的方法默认都是实例方法。它最少也要包含一个self参数。</p><p><strong>类方法：</strong>类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 cls，Python会自动将类本身绑定给cls参数（注意，绑定的不是类对象）。也就是说，我们在调用类方法时，无需显式为cls参数传参。类方法中不能访问实例成员，实例方法中可以访问类成员。用于操作类变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@classmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法名称</span>(<span class="params">cls,参数列表</span>):</span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure><p><strong>静态方法：</strong>其实就是我们学过的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。定义常用的工具函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">方法名称</span>(<span class="params">参数列表</span>):</span><br><span class="line">    方法体</span><br></pre></td></tr></table></figure><h2 id="三大特征"><a href="#三大特征" class="headerlink" title="三大特征"></a>三大特征</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>面向对象的封装是指将数据（属性）和操作数据的方法（方法）打包在一起，形成一个类。这个类对外部隐藏了其内部的具体实现细节，只暴露一些必要的接口，使得对象的使用者无需关心对象内部是如何实现的。</p><p>隐藏：刻意将一些属性和方法隐藏在类的内部，使得在使用此类时，无法直接调用这些属性或方法，只能通过未隐藏的类方法间接操作。在Python中使用双下划线开头的方式将属性或方法隐藏起来（设置成私有的），即双下划线前缀。私有成员的名称被修改为：<code>_类名__成员名</code>。</p><p>属性@property的使用：公开的实例变量可以使用 <code>@property</code> 装饰器创建属性。私有的实例变量通过两个公开的方法相结合，使调用者的操作略显复杂。属性可以将两个方法的使用方式像操作变量一样方便。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">属性名</span>(<span class="params">self</span>):</span><br><span class="line"><span class="keyword">return</span> self.__属性名</span><br><span class="line"></span><br><span class="line"><span class="meta">@属性名.setter</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">属性名</span>(<span class="params">self, value</span>):</span><br><span class="line">self.__属性名= value</span><br><span class="line">    </span><br><span class="line">对象.属性名 = 数据</span><br><span class="line">变量 = 对象.属性名</span><br></pre></td></tr></table></figure><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是面向对象编程中的一个重要概念，它允许一个类（称为子类或派生类）继承另一个类（称为父类或基类）的属性和方法。这种机制使得代码的重用变得更加容易，并提供了一种层次化的组织方式。</p><p>在Python中，通过在类定义中添加括号里的父类名称来实现继承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span>:</span><br><span class="line">    <span class="comment"># 父类的属性和方法</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>(<span class="title class_ inherited__">ParentClass</span>):</span><br><span class="line">    <span class="comment"># 子类继承了父类的属性和方法，可以新增或者覆盖</span></span><br></pre></td></tr></table></figure><ul><li><strong>子类可以继承父类的属性和方法。</strong> 这意味着子类可以使用父类中定义的所有属性和方法。</li><li><strong>子类可以新增属性和方法。</strong> 子类可以在自身中定义新的属性和方法，扩展了父类的功能。</li><li><strong>子类可以覆盖父类的方法。</strong> 如果子类定义了与父类同名的方法，那么子类的方法将覆盖父类的方法。</li></ul><p><code>super()</code> 函数用于调用父类的方法。在子类中，通过 <code>super().父类方法()</code> 可以调用父类的方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParentClass</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;父类方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">ChildClass</span>(<span class="title class_ inherited__">ParentClass</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">some_method</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="built_in">super</span>().some_method()  <span class="comment"># 调用父类方法</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;子类方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建子类对象</span></span><br><span class="line">child_obj = ChildClass()</span><br><span class="line">child_obj.some_method()</span><br></pre></td></tr></table></figure><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>在Python中，多态性是通过对象的方法重写（覆盖）来实现的，具体体现在运行时多态性。在Python中，不同类的对象可以对相同的消息作出响应。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Animal</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Bark&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cat</span>(<span class="title class_ inherited__">Animal</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">make_sound</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Meow&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">animal_sound</span>(<span class="params">animal</span>):</span><br><span class="line">    <span class="keyword">return</span> animal.make_sound()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建 Dog 和 Cat 对象</span></span><br><span class="line">dog = Dog()</span><br><span class="line">cat = Cat()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 animal_sound 函数，传入不同类型的对象</span></span><br><span class="line"><span class="built_in">print</span>(animal_sound(dog))  <span class="comment"># 输出 Bark</span></span><br><span class="line"><span class="built_in">print</span>(animal_sound(cat))  <span class="comment"># 输出 Meow</span></span><br></pre></td></tr></table></figure><h2 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h2><p>如果没有指定父类，python的类会默认继承object类，object是所有python类的基类，它提供了一些常见方法这些方法都是<code>__方法__</code>格式，这些方法会再某种情况下自动触发执行。我们可以在自定义类中进行重写，从而改变其行为。</p><table><thead><tr><th align="center">方法名</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><code>__add__</code></td><td align="center">加法</td></tr><tr><td align="center"><code>__sub__</code></td><td align="center">减法</td></tr><tr><td align="center"><code>__mul__</code></td><td align="center">乘法</td></tr><tr><td align="center"><code>__truediv__</code></td><td align="center">除法</td></tr><tr><td align="center"><code>__floodiv__</code></td><td align="center">地板除</td></tr><tr><td align="center"><code>__mod__</code></td><td align="center">求余</td></tr><tr><td align="center"><code>__pow__</code></td><td align="center">幂</td></tr><tr><td align="center"><code>__iadd__</code></td><td align="center">+&#x3D;</td></tr><tr><td align="center"><code>__isub__</code></td><td align="center">-&#x3D;</td></tr><tr><td align="center"><code>__imul__</code></td><td align="center">*&#x3D;</td></tr><tr><td align="center"><code>__itruediv__</code></td><td align="center">&#x2F;&#x3D;</td></tr><tr><td align="center"><code>__ifloodiv__</code></td><td align="center">&#x2F;&#x2F;&#x3D;</td></tr><tr><td align="center"><code>__imod__</code></td><td align="center">%&#x3D;</td></tr><tr><td align="center"><code>__ipow__</code></td><td align="center">**&#x3D;</td></tr><tr><td align="center"><code>__lt__</code></td><td align="center">小于</td></tr><tr><td align="center"><code>__le__</code></td><td align="center">小于等于</td></tr><tr><td align="center"><code>__gt__</code></td><td align="center">大于</td></tr><tr><td align="center"><code>__ge__</code></td><td align="center">大于等于</td></tr><tr><td align="center"><code>__eq__</code></td><td align="center">等于</td></tr><tr><td align="center"><code>__ne__</code></td><td align="center">不等于</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, Point):</span><br><span class="line">            <span class="keyword">return</span> Point(self.x + other.x, self.y + other.y)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Unsupported operand type&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建两个 Point 对象</span></span><br><span class="line">p1 = Point(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">p2 = Point(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用重载的 + 运算符</span></span><br><span class="line">result = p1 + p2</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(result.x, result.y)  <span class="comment"># 输出 4 6</span></span><br></pre></td></tr></table></figure><p><code>__str__</code>方法，当调用内置的 <code>str()</code> 函数或者 <code>print()</code> 函数时，如果对象实现了 <code>__str__</code> 方法，将会调用该方法并返回其结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, x, y</span>):</span><br><span class="line">        self.x = x</span><br><span class="line">        self.y = y</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> <span class="string">f&quot;Point(<span class="subst">&#123;self.x&#125;</span>, <span class="subst">&#123;self.y&#125;</span>)&quot;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 Point 对象</span></span><br><span class="line">point = Point(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用内置的 str() 函数，触发 __str__ 方法</span></span><br><span class="line">result_str = <span class="built_in">str</span>(point)</span><br><span class="line"><span class="built_in">print</span>(result_str)  <span class="comment"># 输出 &quot;Point(3, 5)&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用内置的 print() 函数，触发 __str__ 方法</span></span><br><span class="line"><span class="built_in">print</span>(point)  <span class="comment"># 输出 &quot;Point(3, 5)&quot;</span></span><br></pre></td></tr></table></figure><p><code>__getitem__</code>、<code>__setitem__</code>、<code>__delitem__</code> 是用于实现对象的索引操作的特殊方法。这些方法允许你在自定义类中使用类似于列表或字典的访问方式。</p><ol><li><code>__getitem__(self, key)</code>: 用于实现索引操作，当使用 <code>obj[key]</code> 时被调用。</li><li><code>__setitem__(self, key, value)</code>: 用于实现对索引元素的赋值操作，当使用 <code>obj[key] = value</code> 时被调用。</li><li><code>__delitem__(self, key)</code>: 用于实现删除索引元素的操作，当使用 <code>del obj[key]</code> 时被调用。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyList</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self</span>):</span><br><span class="line">        self.data = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__getitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">return</span> self.data[index]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__setitem__</span>(<span class="params">self, index, value</span>):</span><br><span class="line">        self.data[index] = value</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__delitem__</span>(<span class="params">self, index</span>):</span><br><span class="line">        <span class="keyword">del</span> self.data[index]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个 MyList 对象</span></span><br><span class="line">my_list = MyList()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __setitem__ 方法赋值</span></span><br><span class="line">my_list[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">my_list[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">my_list[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __getitem__ 方法取值</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 输出 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 __delitem__ 方法删除元素</span></span><br><span class="line"><span class="keyword">del</span> my_list[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看剩余的元素</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">0</span>])  <span class="comment"># 输出 1</span></span><br><span class="line"><span class="built_in">print</span>(my_list[<span class="number">1</span>])  <span class="comment"># 抛出 IndexError 异常，因为元素已被删除</span></span><br></pre></td></tr></table></figure><p>描述符：描述符是一种实现了特定协议的对象，主要用于管理对类属性的访问。</p><ol><li><code>__get__(self, instance, owner)</code>: 用于获取属性的值。当通过实例访问属性时调用。</li><li><code>__set__(self, instance, value)</code>: 用于设置属性的值。当通过实例对属性赋值时调用。</li><li><code>__delete__(self, instance)</code>: 用于删除属性的值。当通过 <code>del</code> 语句删除属性时调用。</li></ol><p>描述符类产生的实例进行属性操作并不会触发三个方法的执行，必须把描述符定义成这个类的类属性，那么每次查找这个属性时，都会调用描述符的 <code>__get__()</code> 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 <code>__set__()</code> 方法。优先级由高到底分别是 1.类属性 2.描述符 3.实例属性</p><p>描述符是可以实现大部分python类特性中的底层魔法,包括@classmethod,@staticmethd,@property</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyProperty</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">if</span> instance <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">            <span class="keyword">return</span> self</span><br><span class="line">        <span class="keyword">return</span> self.func(instance)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Room</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, name, width, length</span>):</span><br><span class="line">        self.name = name</span><br><span class="line">        self.width = width</span><br><span class="line">        self.length = length</span><br><span class="line"></span><br><span class="line"><span class="meta">    @MyProperty</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">area</span>(<span class="params">self</span>):</span><br><span class="line">        <span class="keyword">return</span> self.width * self.length</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">StaticMethod</span>:</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, func</span>):</span><br><span class="line">        self.func = func</span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__get__</span>(<span class="params">self, instance, owner</span>):</span><br><span class="line">        <span class="keyword">def</span> <span class="title function_">feedback</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">            <span class="keyword">return</span> self.func(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> feedback</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">People</span>:</span><br><span class="line"><span class="meta">    @StaticMethod</span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">say_hi</span>(<span class="params">x, y, z</span>):</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&#x27;------&gt;&#x27;</span>, x, y, z)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用模块</title>
      <link href="/post/22639fef.html"/>
      <url>/post/22639fef.html</url>
      
        <content type="html"><![CDATA[<h2 id="时间模块"><a href="#时间模块" class="headerlink" title="时间模块"></a>时间模块</h2><p><code>time</code>和<code>datetime</code>是Python中用于处理时间的两个主要模块，它们有不同的功能和应用场景。</p><p><code>time</code>主要用于基本的时间测量和表示，而 <code>datetime</code> 更适用于复杂的日期和时间操作。</p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>“时间测量”指的是衡量或度量时间的经过。time模块提供了一种方式来获取程序执行的时间、两个事件之间的时间间隔等信息。主要的时间测量函数是time.time()，它返回的是自1970年1月1日以来的秒数，也称为时间戳。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">start_time = time.time()</span><br><span class="line"><span class="comment"># 执行一些代码</span></span><br><span class="line">end_time = time.time()</span><br><span class="line">elapsed_time = end_time - start_time</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;代码执行时间为：<span class="subst">&#123;elapsed_time&#125;</span> 秒&quot;</span>)</span><br></pre></td></tr></table></figure><p>在<code>time</code>模块中，时间可以以不同的形式进行表示</p><p><strong>时间戳表示：</strong> 使用 <code>time.time()</code> 函数获取自1970年1月1日以来的秒数，这个秒数就是时间戳的表示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">current_timestamp = time.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前时间戳：<span class="subst">&#123;current_timestamp&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>格式化的时间字符串表示：</strong> 以人可读的方式呈现时间信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S %p&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;格式化的时间字符串：<span class="subst">&#123;formatted_time&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><p><strong>结构化时间表示：</strong> 使用 <code>time.localtime()</code> 函数获取本地时区的结构化时间对象，其中包含年、月、日、时、分、秒等信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">local_struct_time = time.localtime()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;年&#x27;</span>, local_struct_time.tm_year)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;月&#x27;</span>, local_struct_time.tm_mon)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;日&#x27;</span>, local_struct_time.tm_mday)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;时&#x27;</span>, local_struct_time.tm_hour)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;分&#x27;</span>, local_struct_time.tm_min)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;秒&#x27;</span>, local_struct_time.tm_sec)</span><br><span class="line"><span class="comment"># 取值范围是 0 到 6，分别代表周一到周日。</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;星期&#x27;</span>, local_struct_time.tm_wday + <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;一年中第几天&#x27;</span>, local_struct_time.tm_yday)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.localtime(secs)：将给定的时间戳（秒数）转换为本地时间的结构化时间。返回值是 struct_time 对象。</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">timestamp = time.time()</span><br><span class="line">local_struct_time = time.localtime(timestamp)</span><br><span class="line"><span class="built_in">print</span>(local_struct_time)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.mktime(t)：将给定的结构化时间 (struct_time) 转换为时间戳。</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">struct_time = time.localtime()</span><br><span class="line">timestamp = time.mktime(struct_time)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;转换后的时间戳：<span class="subst">&#123;timestamp&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.strftime(format, t)：将给定的结构化时间 (struct_time) 转换为格式化的时间字符串。</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">struct_time = time.localtime()</span><br><span class="line">formatted_time = time.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>, struct_time)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;格式化的时间字符串：<span class="subst">&#123;formatted_time&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># time.strptime(string, format)：将给定的格式化时间字符串解析为结构化时间 (struct_time)。</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">time_string = <span class="string">&quot;2023-01-01 12:34:56&quot;</span></span><br><span class="line">parsed_time = time.strptime(time_string, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;解析后的结构化时间：<span class="subst">&#123;parsed_time&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><h3 id="datetime"><a href="#datetime" class="headerlink" title="datetime"></a>datetime</h3><p>在涉及到更复杂的时间计算、时间差计算以及日期和时间的组合时，<code>datetime</code> 是一个更好的选择。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取当前日期和时间</span></span><br><span class="line">current_datetime = datetime.now()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;当前日期和时间：<span class="subst">&#123;current_datetime&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取日期部分</span></span><br><span class="line">date_part = current_datetime.date()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;日期部分：<span class="subst">&#123;date_part&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取时间部分</span></span><br><span class="line">time_part = current_datetime.time()</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;时间部分：<span class="subst">&#123;time_part&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 格式化为字符串</span></span><br><span class="line">formatted_datetime = current_datetime.strftime(<span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;格式化的时间字符串：<span class="subst">&#123;formatted_datetime&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 解析字符串为datetime对象</span></span><br><span class="line">time_string = <span class="string">&quot;2023-01-01 12:34:56&quot;</span></span><br><span class="line">parsed_datetime = datetime.strptime(time_string, <span class="string">&quot;%Y-%m-%d %H:%M:%S&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;解析后的datetime对象：<span class="subst">&#123;parsed_datetime&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 时间差计算</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> timedelta</span><br><span class="line">delta = timedelta(days=<span class="number">5</span>, hours=<span class="number">3</span>, minutes=<span class="number">30</span>)</span><br><span class="line">new_datetime = current_datetime + delta</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f&quot;5天3小时30分钟后的时间：<span class="subst">&#123;new_datetime&#125;</span>&quot;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 倒计时效果</span></span><br><span class="line"><span class="keyword">from</span> datetime <span class="keyword">import</span> datetime, timedelta</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置目标日期和时间</span></span><br><span class="line">target_datetime = datetime(<span class="number">2024</span>, <span class="number">2</span>, <span class="number">21</span>, <span class="number">10</span>, <span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="comment"># 获取当前日期和时间</span></span><br><span class="line">    current_datetime = datetime.now()</span><br><span class="line">    <span class="comment"># 计算时间差</span></span><br><span class="line">    time_difference = target_datetime - current_datetime</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断是否已到达目标时间</span></span><br><span class="line">    <span class="keyword">if</span> time_difference.total_seconds() &lt;= <span class="number">0</span>:</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;倒计时结束！&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 将总秒数转换为时分秒</span></span><br><span class="line">    seconds = <span class="built_in">int</span>(time_difference.total_seconds())</span><br><span class="line">    hours, remainder = <span class="built_in">divmod</span>(seconds, <span class="number">3600</span>)</span><br><span class="line">    minutes, seconds = <span class="built_in">divmod</span>(remainder, <span class="number">60</span>)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;\r距离目标时间还有：<span class="subst">&#123;hours&#125;</span>:<span class="subst">&#123;minutes&#125;</span>:<span class="subst">&#123;seconds&#125;</span>&quot;</span>, end=<span class="string">&quot;&quot;</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><h2 id="随机模块"><a href="#随机模块" class="headerlink" title="随机模块"></a>随机模块</h2><p><code>random</code> 模块是Python中用于生成伪随机数的模块，提供了多种随机数生成的函数。</p><ul><li><p><strong><code>random()</code>：</strong> 返回一个位于 [0.0, 1.0) 范围内的随机浮点数。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rand_num = random.random()</span><br><span class="line"><span class="built_in">print</span>(rand_num)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>randint(a, b)</code>：</strong> 返回一个位于 <code>[a, b]</code> 范围内的随机整数。包括<code>a</code>和<code>b</code>本身。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">rand_int = random.randint(<span class="number">1</span>, <span class="number">10</span>)</span><br><span class="line"><span class="built_in">print</span>(rand_int)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>randrange(a, b)</code>：</strong>它用于生成指定范围内的随机整数，支持指定步长。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 生成 [start, stop) 范围内的随机整数</span></span><br><span class="line">result = random.randrange(start, stop, step)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>choice(seq)</code>：</strong> 从序列 <code>seq</code> 中随机选择一个元素。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">rand_choice = random.choice(my_list)</span><br><span class="line"><span class="built_in">print</span>(rand_choice)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>shuffle(seq)</code>：</strong> 将序列 <code>seq</code> 中的元素随机排序，直接修改原序列。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">random.shuffle(my_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br></pre></td></tr></table></figure></li><li><p><strong><code>sample(seq, k)</code>：</strong> 从总体<code>seq</code>中随机选择 <code>k</code> 个唯一的元素。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">random.shuffle(my_list)</span><br><span class="line"><span class="built_in">print</span>(my_list)</span><br></pre></td></tr></table></figure></li></ul><h2 id="OS"><a href="#OS" class="headerlink" title="OS"></a>OS</h2><p>os模块，提供了与操作系统进行交互的功能。它包含了许多用于处理文件路径、执行命令、管理进程、访问环境变量等功能。</p><ul><li><code>os.path.abspath()</code>：用于返回指定路径的绝对路径。</li><li><code>os.path.dirname() </code>：用于返回指定路径的目录部分。</li><li><code>os.path.join()  </code>：用于将多个路径组合成一个完整的路径。</li><li><code>os.path.exists() </code>：用于检查指定路径是否存在。</li><li><code>os.makedirs() </code>：需要传入一个路径作为参数，根据该路径创建对应的目录结构。</li><li><code>os.path.isdir() </code>：用于判断指定路径是否是一个目录。</li><li><code>os.remove() </code>：接受一个文件路径作为参数，并尝试删除该文件。</li><li><code>os.listdir()</code>：返回指定目录中的文件和文件夹列表。</li><li><code>os.walk()</code> ：生成目录中文件和子目录的路径，支持递归遍历。</li></ul><h2 id="sys模块"><a href="#sys模块" class="headerlink" title="sys模块"></a>sys模块</h2><p><code>sys</code>模块允许你在运行时获取关于Python解释器的一些信息。</p><ul><li><code>sys.argv</code>：包含命令行参数的列表。是文件的完整路径。其余的元素是传递的命令行参数。</li><li><code>sys.version</code>：包含Python解释器的版本信息。</li><li><code>sys.executable</code>：返回Python解释器的可执行文件路径。</li><li><code>sys.path</code>：是一个包含模块搜索路径的列表。</li><li><code>sys.exit([arg])</code>：用于退出Python解释器。默认情况下，返回码为 0，表示正常退出。也可以提供一个整数参数，表示错误码。</li></ul><h2 id="openpyxl"><a href="#openpyxl" class="headerlink" title="openpyxl"></a>openpyxl</h2><p><code>openpyxl</code>是一个用于读取和写入Excel文件的Python第三方模块。</p><p>注意：<code>openpyxl</code>只能处理<code>.xlsx</code> 格式文件</p><p>安装<code>openpyxl</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><p>默认情况下，Pip会从Python官方的软件仓库PyPI中下载第三方模块。但是，有时候PyPI并不是最好的选择，因为PyPI可能受到网络限制限制，导致无法访问或访问速度很慢。我们在下载第三方模块的时候一般都会使用第三方源。</p><ul><li>豆瓣源：<a href="https://pypi.doubanio.com/simple/">https://pypi.doubanio.com/simple/</a></li><li>清华源：<a href="https://pypi.tuna.tsinghua.edu.cn/simple/">https://pypi.tuna.tsinghua.edu.cn/simple/</a></li><li>阿里云源：<a href="https://mirrors.aliyun.com/pypi/simple/">https://mirrors.aliyun.com/pypi/simple/</a></li><li>华为云源：<a href="https://mirrors.huaweicloud.com/repository/pypi/simple/">https://mirrors.huaweicloud.com/repository/pypi/simple/</a></li><li>腾讯云源：<a href="https://mirrors.cloud.tencent.com/pypi/simple/">https://mirrors.cloud.tencent.com/pypi/simple/</a></li><li>台湾源：<a href="https://pypi.org.tw/simple/">https://pypi.org.tw/simple/</a></li><li>北京理工大学源：<a href="http://pypi.bjtu.edu.cn/simple/">http://pypi.bjtu.edu.cn/simple/</a></li><li>华中科技大学源：<a href="http://pypi.hustunique.com/simple/">http://pypi.hustunique.com/simple/</a></li><li>北京交通大学源：<a href="http://mirror.bjtu.edu.cn/pypi/simple/">http://mirror.bjtu.edu.cn/pypi/simple/</a></li></ul><p>要使用第三反源下载模块，在使用Pip时，使用<code>-i</code>选项，指定要使用的源地址</p><p><code>pip install package_name -i https://pypi.doubanio.com/simple/</code></p><p>工作簿、工作表、单元格之间的关系：</p><ul><li>一个工作簿(workbook)由多个工作表(worksheet)组成</li><li>一个工作表有多个单元格(cell)组成；</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个Excel文件</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> workbook</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建一个工作簿（workbook）对象</span></span><br><span class="line">workbook = workbook.Workbook()</span><br><span class="line">workbook.save(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 读取Excel文件</span></span><br><span class="line"><span class="keyword">from</span> openpyxl <span class="keyword">import</span> load_workbook</span><br><span class="line"></span><br><span class="line">workbook = load_workbook(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># sheet相关操作</span></span><br><span class="line"><span class="comment"># 1. sheetnames是Workbook对象的一个属性，用于返回Excel文件中所有工作表的名称列表。</span></span><br><span class="line">sheet_names = workbook.sheetnames</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 通过名称选择工作表</span></span><br><span class="line">worksheet1 = workbook[<span class="string">&#x27;Sheet1&#x27;</span>]</span><br><span class="line">cell = worksheet1.cell(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 通过索引选择工作表</span></span><br><span class="line">worksheet2 = workbook.worksheets[<span class="number">1</span>]</span><br><span class="line">cell = worksheet1.cell(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="built_in">print</span>(cell.value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 遍历所有工作表</span></span><br><span class="line"><span class="keyword">for</span> worksheet <span class="keyword">in</span> workbook.worksheets:</span><br><span class="line">    cell = worksheet.cell(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="built_in">print</span>(cell.value)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5. 添加工作表</span></span><br><span class="line">worksheet2 = workbook.create_sheet(<span class="string">&#x27;Sheet2&#x27;</span>)</span><br><span class="line">workbook.save(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 删除工作表</span></span><br><span class="line">worksheet = workbook[<span class="string">&#x27;工作表&#x27;</span>]</span><br><span class="line">workbook.remove(worksheet)</span><br><span class="line">workbook.save(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 修改sheet名称</span></span><br><span class="line">workbook = load_workbook(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br><span class="line">worksheet = workbook[<span class="string">&#x27;Sheet&#x27;</span>]</span><br><span class="line">worksheet.title = <span class="string">&#x27;My Worksheet&#x27;</span></span><br><span class="line">workbook.save(<span class="string">&#x27;example.xlsx&#x27;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 8. 获取工作表的最大行数和最大列数</span></span><br><span class="line"><span class="built_in">print</span>(worksheet.max_row)</span><br><span class="line"><span class="built_in">print</span>(worksheet.max_column)</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 单元格操作</span></span><br><span class="line"><span class="comment"># 1. 要读取单元格的值，可以通过工作表对象的索引或cell()方法来获取单元格对象，然后使用value属性获取单元格的值。</span></span><br><span class="line"><span class="comment"># 1.1 通过索引获取单元格对象</span></span><br><span class="line">cell = worksheet[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line"><span class="comment"># 1.2 通过cell()方法获取单元格对象</span></span><br><span class="line">cell = worksheet.cell(<span class="number">1</span>, <span class="number">1</span>)  <span class="comment"># 获取第N行第N列的单元格(位置是从1开始）</span></span><br><span class="line">value = cell.value</span><br><span class="line"><span class="built_in">print</span>(value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 遍历Excel工作表中所有行的单元格。</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> worksheet.rows:</span><br><span class="line">    <span class="keyword">for</span> cell <span class="keyword">in</span> row:</span><br><span class="line">        <span class="built_in">print</span>(cell.value)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># 3. 遍历所有行</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">min_row：指定遍历的起始行，默认为 1。</span></span><br><span class="line"><span class="string">max_row：指定遍历的结束行，默认为工作表的最大行数。</span></span><br><span class="line"><span class="string">min_col 和 max_col：可选参数，指定遍历的列范围，默认为 None，表示遍历所有列。</span></span><br><span class="line"><span class="string">values_only：可选参数，设置为 True 时，返回的是单元格的值而不是单元格对象，默认为 False。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> sheet.iter_rows(min_row=<span class="number">1</span>, max_row=sheet.max_row, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(row)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 遍历所有列</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">min_col：指定遍历的起始列，默认为 1。</span></span><br><span class="line"><span class="string">max_col：指定遍历的结束列，默认为工作表的最大列数。</span></span><br><span class="line"><span class="string">min_row 和 max_row：可选参数，指定遍历的行范围，默认为 None，表示遍历所有行。</span></span><br><span class="line"><span class="string">values_only：可选参数，设置为 True 时，返回的是单元格的值而不是单元格对象，默认为 False。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> column <span class="keyword">in</span> sheet.iter_cols(min_col=<span class="number">1</span>, max_col=sheet.max_column, values_only=<span class="literal">True</span>):</span><br><span class="line">    <span class="built_in">print</span>(column)</span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"><span class="comment"># 5. 样式</span></span><br><span class="line"><span class="comment"># 5.1 Font对象：用于设置字体样式，例如字体名称、大小、颜色等。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">name：指定字体的名称，例如 Arial、Times New Roman 等。</span></span><br><span class="line"><span class="string">size：指定字体的大小，以磅为单位。</span></span><br><span class="line"><span class="string">bold：指定是否使用粗体。</span></span><br><span class="line"><span class="string">italic：指定是否使用斜体。</span></span><br><span class="line"><span class="string">strikethrough：指定是否使用删除线。</span></span><br><span class="line"><span class="string">color：指定字体颜色，可以是 RGB 颜色代码（例如 &#x27;FF0000&#x27; 表示红色）或预定义的颜色名称（例如 &#x27;red&#x27;）</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="comment"># 字体名称（Arial）、字号（12）、加粗和红色字体颜色属性。</span></span><br><span class="line">font = Font(name=<span class="string">&#x27;Arial&#x27;</span>, size=<span class="number">12</span>, bold=<span class="literal">True</span>, color=<span class="string">&#x27;FF0000&#x27;</span>)</span><br><span class="line">cell = worksheet[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line">cell.font = font</span><br><span class="line">cell.value = <span class="string">&#x27;Hello, world!&#x27;</span></span><br><span class="line"><span class="comment"># 5.2 Alignment对象：用于设置单元格文本的对齐方式，例如水平对齐、垂直对齐等。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">参数：</span></span><br><span class="line"><span class="string">horizontal：指定文本的水平对齐方式，可选值为 left、center、right</span></span><br><span class="line"><span class="string">vertical：指定文本的垂直对齐方式，可选值为 top、center、bottom</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">alignment = Alignment(horizontal=<span class="string">&#x27;center&#x27;</span>, vertical=<span class="string">&#x27;center&#x27;</span>)  <span class="comment"># 水平居中、垂直居中</span></span><br><span class="line">cell = worksheet[<span class="string">&#x27;A1&#x27;</span>]</span><br><span class="line">cell.alignment = alignment</span><br><span class="line">cell.value = <span class="string">&#x27;Hello, world!&#x27;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>模块与包</title>
      <link href="/post/3a3b1e59.html"/>
      <url>/post/3a3b1e59.html</url>
      
        <content type="html"><![CDATA[<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><p>在Python中，模块是一种组织代码的方式，可以将相关的功能封装在一个单独的文件中，以便在其他程序中重复使用。Python中模块可以分为内置的模块、第三方的模块、自定义的模块。</p><ul><li><p><strong>创建模块：</strong> 创建一个模块很简单，只需创建一个包含Python代码的文件，并以<code>.py</code>为扩展名。例如，创建一个名为<code>mymodule.py</code>的模块文件。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># mymodule.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>!&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">a, b</span>):</span><br><span class="line">    <span class="keyword">return</span> a + b</span><br></pre></td></tr></table></figure></li><li><p><strong>导入模块：</strong> 在其他Python文件中，可以使用<code>import</code>关键字导入模块，然后使用模块中的功能。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># main.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> mymodule</span><br><span class="line"></span><br><span class="line">mymodule.greet(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line">result = mymodule.add(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ul><p>当我们导入一个模块时，模块内的所有语句都会被执行。并创建一个模块对象，该对象包含了模块中定义的函数、类和变量等。以供后续导入和使用。</p><p>如果一个模块已经被导入过了，再次导入同一个模块时，Python会直接使用先前创建的模块对象，而不会重新执行模块内的语句。这是为了避免重复执行相同的代码，以提高性能并避免可能的副作用。</p><p>这意味着，当你在一个程序中多次导入同一个模块时，模块内的代码只会在第一次导入时执行一次。后续的导入操作将直接使用先前创建的模块对象。</p><h3 id="模块导入语法"><a href="#模块导入语法" class="headerlink" title="模块导入语法"></a>模块导入语法</h3><ul><li><code>import</code> 语句的作用是将整个模块导入到当前模块中。你可以使用模块名作为前缀来访问模块中的成员。</li><li><code>import</code> 语句也可以使用 <code>as</code> 关键字为模块设置别名，以便在当前模块中更方便地引用它。这对于模块名很长或容易与其他名称冲突的情况很有用。</li><li><code>from import</code>语句用于从模块中导入特定的成员到当前模块的作用域中。你可以直接使用成员名进行访问，无需使用模块名前缀。这种方式可以减少代码中的冗长，并提供更直接的访问方式。</li><li><code>from import *</code> 语句用于将一个模块中的所有成员导入到当前模块中。这种方式不推荐使用，因为它可能导致命名冲突和命名空间污染。通常建议明确导入所需的成员，以提高代码的可读性和可维护性。</li><li><code>__all__</code> 变量用于定义可以被导入的成员列表。当使用 <code>from module import *</code> 语句时，只有列在 <code>__all__</code> 变量中的成员才会被导入，其他成员将被视为隐藏成员。</li></ul><h3 id="内置变量"><a href="#内置变量" class="headerlink" title="内置变量"></a>内置变量</h3><p>内置变量是Python语言本身提供的一些特殊变量，它们在解释器中预先定义，不需要导入任何模块就可以直接使用。这些内置变量具有特定的用途和功能。</p><ul><li><code>__name__</code>：描述了当前模块的名称。当模块作为主程序直接执行时，<code>__name__</code> 的值为<code>&#39;__main__&#39;</code>；当模块被其他模块导入时，<code>__name__</code> 的值为模块的名称。</li><li><code>__file__</code>：描述了当前模块所在的文件路径名。</li></ul><h3 id="模块搜索路径"><a href="#模块搜索路径" class="headerlink" title="模块搜索路径"></a>模块搜索路径</h3><p>当你导入一个模块时，Python解释器会按照一定的顺序搜索模块文件。搜索路径包括内置模块、<code>sys.path</code>中列出的目录以及一些其他位置。你可以通过修改<code>sys.path</code>来添加自定义的模块搜索路径。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加自定义模块搜索路径</span></span><br><span class="line">sys.path.append(<span class="string">&#x27;/path/to/your/module&#x27;</span>)</span><br></pre></td></tr></table></figure><p>当你导入一个模块时，Python解释器会按照一定的顺序搜索模块文件。</p><h3 id="循环导入问题"><a href="#循环导入问题" class="headerlink" title="循环导入问题"></a>循环导入问题</h3><p>循环导入是指两个或多个模块相互导入，形成了一个导入的闭环。这可能导致程序在执行时出现问题。Python在检测到循环导入时会抛出<code>ImportError</code>异常。</p><p>循环导入的问题通常发生在模块之间存在相互引用的情况下，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module1.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module2 <span class="keyword">import</span> function_in_module2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_in_module1</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function in module 1&quot;</span>)</span><br><span class="line">    function_in_module2()</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module2.py</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> module1 <span class="keyword">import</span> function_in_module1</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_in_module2</span>():</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function in module 2&quot;</span>)</span><br><span class="line">    function_in_module1()</span><br></pre></td></tr></table></figure><p><strong>延迟导入：</strong> 在需要时才导入模块，而不是在模块的顶部导入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># module1.py</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">function_in_module1</span>():</span><br><span class="line">    <span class="keyword">from</span> module2 <span class="keyword">import</span> function_in_module2</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;Function in module 1&quot;</span>)</span><br><span class="line">    function_in_module2()</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="包"><a href="#包" class="headerlink" title="包"></a>包</h2><p>在Python中，包是一种用于组织模块的层次结构。它允许将相关的模块放在一个目录中，以便更好地组织和管理代码。一个包通常包含一个特殊的 <code>__init__.py</code> 文件，用于标识该目录为一个包。在 <code>__init__.py</code> 中，你可以执行一些初始化工作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mypackage/</span><br><span class="line">|-- __init__.py</span><br><span class="line">|-- module1.py</span><br><span class="line">|-- module2.py</span><br><span class="line">|-- subpackage/</span><br><span class="line">|   |-- __init__.py</span><br><span class="line">|   |-- module3.py</span><br></pre></td></tr></table></figure><p><code>mypackage</code>是一个包，包含了两个模块<code>module1.py</code>和<code>module2.py</code>，以及一个子包<code>subpackage</code>，其中包含了<code>module3.py</code>。从Python 3.3版本开始，<code>__init__.py</code>文件不再是必需的，但为了兼容和清晰性，建议保留这个文件。</p><p>当导入包时，<code>__init__.py</code> 文件的代码会被执行一次。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python导入模块时的一个重要原则“点号”的左边必须是一个包。</span></span><br><span class="line"><span class="keyword">from</span> mypackage <span class="keyword">import</span> module1</span><br><span class="line"><span class="keyword">from</span> mypackage.subpackage <span class="keyword">import</span> module3</span><br><span class="line"></span><br><span class="line">module1.function_in_module1()</span><br><span class="line">module3.function_in_module3()</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数(下)</title>
      <link href="/post/aa90b6ef.html"/>
      <url>/post/aa90b6ef.html</url>
      
        <content type="html"><![CDATA[<h2 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h2><p>匿名函数，也称为lambda函数，是一种在代码中创建函数的方式，它没有显式的函数定义和命名。匿名函数通常用于一次性的、简单的函数操作。</p><p>匿名函数的语法形式是：<code>lambda arguments: expression</code>，其中 <code>arguments</code> 是函数的参数，<code>expression</code> 是函数的返回值。匿名函数可以有多个参数，但只能有一个表达式作为函数体，并且该表达式的结果会被隐式地返回。</p><p><code>map</code>()函数：接受两个参数：一个函数和一个可迭代对象。<code>map()</code>函数将传入的函数应用于可迭代对象中的每个元素，并返回一个新的可迭代对象，其中包含应用函数后的结果。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable)</span><br></pre></td></tr></table></figure><ul><li><code>function</code>：一个函数，接受一个参数并返回一个值。</li><li><code>iterable</code>：一个可迭代对象，例如列表、元组、集合等。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将列表中的每个元素加倍</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared_numbers = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(squared_numbers))</span><br></pre></td></tr></table></figure><p><code>filter()</code>函数：它接受两个参数：一个函数和一个可迭代对象。<code>filter()</code>函数通过将传入的函数应用于可迭代对象中的每个元素，并返回一个新的可迭代对象，其中包含满足函数条件的元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure><ul><li><code>function</code>：一个函数，接受一个参数并返回一个布尔值（<code>True</code>或<code>False</code>）。</li><li><code>iterable</code>：一个可迭代对象，例如列表、元组、集合等。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 筛选出列表中的偶数</span></span><br><span class="line">numbers = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">even_numbers = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">0</span>, numbers)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(even_numbers))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出字符串列表中长度大于等于5的字符串</span></span><br><span class="line">words = [<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;cherry&#x27;</span>, <span class="string">&#x27;date&#x27;</span>, <span class="string">&#x27;elderberry&#x27;</span>]</span><br><span class="line">long_words = <span class="built_in">filter</span>(<span class="keyword">lambda</span> word: <span class="built_in">len</span>(word) &gt;= <span class="number">5</span>, words)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(long_words))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 筛选出字典列表中满足特定条件的字典</span></span><br><span class="line">people = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">]</span><br><span class="line">adults = <span class="built_in">filter</span>(<span class="keyword">lambda</span> person: person[<span class="string">&quot;age&quot;</span>] &gt;= <span class="number">18</span>, people)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">list</span>(adults))</span><br></pre></td></tr></table></figure><p><code>sorted()</code>函数：用于对可迭代对象进行排序操作。它接受一个可迭代对象作为参数，并返回一个新的已排序的列表。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sorted</span>(iterable, key=<span class="literal">None</span>, reverse=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure><ul><li><code>iterable</code>：一个可迭代对象，例如列表、元组、集合等。</li><li><code>key</code>（可选）：一个函数，用于指定排序的关键字。默认为<code>None</code>，表示使用元素自身进行比较。</li><li><code>reverse</code>（可选）：一个布尔值，用于指定排序顺序。默认为<code>False</code>，表示升序排序；设置为<code>True</code>时表示降序排序。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 对列表进行升序排序</span></span><br><span class="line">numbers = [<span class="number">5</span>, <span class="number">2</span>, <span class="number">8</span>, <span class="number">3</span>, <span class="number">1</span>]</span><br><span class="line">sorted_numbers = <span class="built_in">sorted</span>(numbers)</span><br><span class="line"><span class="built_in">print</span>(sorted_numbers)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 对字典列表按照特定字段进行排序</span></span><br><span class="line">people = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">]</span><br><span class="line">sorted_people = <span class="built_in">sorted</span>(people, key=<span class="keyword">lambda</span> person: person[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(sorted_people)</span><br></pre></td></tr></table></figure><p><code>max()</code>和<code>min()</code>函数：用于获取可迭代对象中的最大值和最小值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">max</span>(iterable, key=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><ul><li><code>iterable</code>：一个可迭代对象。</li><li><code>key</code>（可选）：一个函数，用于指定比较的关键字。默认为<code>None</code>，表示使用元素自身进行比较。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取字典列表中特定字段的最大值和最小值</span></span><br><span class="line">people = [</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">25</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">18</span>&#125;,</span><br><span class="line">    &#123;<span class="string">&quot;name&quot;</span>: <span class="string">&quot;Charlie&quot;</span>, <span class="string">&quot;age&quot;</span>: <span class="number">30</span>&#125;</span><br><span class="line">]</span><br><span class="line">oldest_person = <span class="built_in">max</span>(people, key=<span class="keyword">lambda</span> person: person[<span class="string">&quot;age&quot;</span>])</span><br><span class="line">youngest_person = <span class="built_in">min</span>(people, key=<span class="keyword">lambda</span> person: person[<span class="string">&quot;age&quot;</span>])</span><br><span class="line"><span class="built_in">print</span>(oldest_person)</span><br><span class="line"><span class="built_in">print</span>(youngest_person)</span><br></pre></td></tr></table></figure><h2 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a>open函数</h2><p><code>open()</code>函数用于打开文件，并返回一个文件对象，可以用于读取、写入或操作文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">file_object = <span class="built_in">open</span>(</span><br><span class="line">    <span class="string">&#x27;file&#x27;</span>,  <span class="comment"># 文件路径</span></span><br><span class="line">    mode=<span class="string">&#x27;r&#x27;</span>,  <span class="comment"># 打开文件的模式,如果不写默认为‘r’</span></span><br><span class="line">    encoding=<span class="literal">None</span>,  <span class="comment"># 设置打开文件的编码方式</span></span><br><span class="line">    buffering=-<span class="number">1</span>  <span class="comment"># 1表示有行缓冲，默认则表示使用系统默认提供的缓冲机制。</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>文件路径用于指定文件的位置。文件路径可以是相对路径或绝对路径。</p><ul><li>绝对路径：总是从根文件夹开始，Window 系统中以盘符（C：、D：）作为根文件夹。</li><li>相对路径：指的是文件相对于当前工作目录所在的位置。</li></ul><p>打开文件的模式：</p><table><thead><tr><th align="center">打开模式</th><th align="center">效果</th></tr></thead><tbody><tr><td align="center">r</td><td align="center">以读方式打开，文件必须存在</td></tr><tr><td align="center">w</td><td align="center">以写方式打开，文件不存在则创建，存在清空原有内容</td></tr><tr><td align="center">a</td><td align="center">以追加模式打开，文件不存在则创建，存在则继续进行写操作</td></tr><tr><td align="center">r+</td><td align="center">以读写模式打开 文件必须存在</td></tr><tr><td align="center">w+</td><td align="center">以读写模式打开文件，不存在则创建，存在清空原有内容</td></tr><tr><td align="center">a+</td><td align="center">追加并可读模式，文件不存在则创建，存在则继续进行写操作</td></tr><tr><td align="center">rb</td><td align="center">以二进制读模式打开 同r</td></tr><tr><td align="center">wb</td><td align="center">以二进制写模式打开 同w</td></tr><tr><td align="center">ab</td><td align="center">以二进制追加模式打开 同a</td></tr><tr><td align="center">rb+</td><td align="center">以二进制读写模式打开 同r+</td></tr><tr><td align="center">wb+</td><td align="center">以二进制读写模式打开 同w+</td></tr><tr><td align="center">ab+</td><td align="center">以二进制读写模式打开 同a+</td></tr></tbody></table><p>字符编码：字符编码是一种将字符映射到二进制数据的规则或方案。由于计算机内部是以二进制形式存储和处理数据，因此需要一种方式来表示和处理文本字符。</p><ul><li>ASCII：ASCII是最早的字符编码方案，使用7位二进制数表示128个标准ASCII字符，包括英文字母、数字和一些常见的符号。ASCII只能表示英文字符，无法表示其他语言字符。</li><li>GBK：GBK是中国制定的字符编码标准，用于表示中文字符和英文字符。GBK扩展了ASCII编码，一个英文字符使用1个字节（8位）表示，一个中文字符使用2个字节（16位）表示。</li><li>Unicode：Unicode是一种字符编码标准，旨在统一全球各个语言的字符表示。Unicode可以表示几乎所有的语言字符，包括英文、中文、日文以及其他语言字符。UCS-2使用2个字节表示每个字符，而UCS-4使用4个字节表示每个字符。UCS-4可以表示Unicode的全部字符，但在存储和传输上占用的空间较大。</li><li>UTF-8：UTF-8是Unicode的一种变长字符编码方案。它可以使用1至4个字节来表示一个字符，根据字符的不同而变化字节长度。UTF-8编码中的ASCII字符（0-127）与标准的ASCII编码是相同的，所以UTF-8编码是兼容ASCII的。UTF-8编码的优点是可以节省存储空间，因为它能够灵活地根据字符的实际需要来调整字节长度。对于使用较少的字符，只需使用1个字节表示，而对于需要表示更多字符的语言，则使用2、3或4个字节。</li></ul><h3 id="文件对象读取操作"><a href="#文件对象读取操作" class="headerlink" title="文件对象读取操作"></a>文件对象读取操作</h3><ul><li><code>read(size)</code>: 读取指定大小的字符数或字节数，并返回读取的内容作为字符串或字节对象。如果省略<code>size</code>参数或指定为负数，则读取整个文件内容。</li><li><code>readline()</code>: 逐行读取文件内容，每次读取一行，并返回包含该行内容的字符串。</li><li><code>readlines()</code>: 一次性读取整个文件内容，并将每行内容作为字符串存储在列表中返回。</li><li>文件对象本身也是一个可迭代对象，在for循环中可以迭代文件的每一行。</li></ul><h3 id="文件对象写入操作"><a href="#文件对象写入操作" class="headerlink" title="文件对象写入操作"></a>文件对象写入操作</h3><ul><li><code>write(str)</code>: 将指定的字符串写入文件。如果文件以文本模式打开，参数<code>str</code>必须是字符串类型。如果文件以二进制模式打开，参数<code>str</code>可以是字节对象。</li><li><code>writelines(lines)</code>: 将一个字符串列表写入文件。每个字符串都会被写入为一行。需要注意的是，<code>writelines()</code>方法不会自动在每行末尾添加换行符，需要手动添加。</li></ul><h3 id="关闭文件"><a href="#关闭文件" class="headerlink" title="关闭文件"></a>关闭文件</h3><p>打开一个文件后我们就可以通过文件对象对文件进行操作了，当操作结束后可以关闭文件操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file_object.close()</span><br></pre></td></tr></table></figure><ul><li>可以销毁对象节省资源</li><li>防止后面对这个对象的误操作。</li></ul><h3 id="with语句"><a href="#with语句" class="headerlink" title="with语句"></a>with语句</h3><p>在Python中，<code>with</code>语句提供了一种方便的方式来管理资源，例如文件操作、网络连接等。它可以确保在使用完资源后自动进行清理和释放。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> 资源 <span class="keyword">as</span> 变量:</span><br><span class="line">    <span class="comment"># 在此处使用资源进行操作</span></span><br><span class="line">    <span class="comment"># 代码块结束后，资源会自动进行清理和释放</span></span><br></pre></td></tr></table></figure><p>一个常见的应用是使用<code>with</code>语句来打开文件，进行文件操作，然后自动关闭文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;file.txt&#x27;</span>, <span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> file_object:</span><br><span class="line">    content = file_object.read()</span><br><span class="line">    <span class="built_in">print</span>(content)</span><br><span class="line"><span class="comment"># 在这里，文件已经自动关闭</span></span><br></pre></td></tr></table></figure><h2 id="内置函数"><a href="#内置函数" class="headerlink" title="内置函数"></a>内置函数</h2><ul><li><code>print()</code>: 打印输出内容到控制台。</li><li><code>input()</code>: 从用户输入读取一行文本。</li><li><code>len()</code>: 返回对象的长度或元素个数。</li><li><code>type()</code>: 返回对象的类型。</li><li><code>range()</code>: 生成一个指定范围的整数序列。</li><li><code>sum()</code>: 计算可迭代对象的总和。</li><li><code>max()</code>: 返回可迭代对象的最大值。</li><li><code>min()</code>: 返回可迭代对象的最小值。</li><li><code>abs()</code>: 返回一个数的绝对值。</li><li><code>round()</code>: 对一个数进行四舍五入。</li><li><code>sorted()</code>: 对可迭代对象进行排序并返回一个新列表。</li><li><code>any()</code>: 判断可迭代对象中是否存在至少一个为真的元素。</li><li><code>all()</code>: 判断可迭代对象中所有元素是否都为真。</li><li><code>zip()</code>: 将多个可迭代对象打包成一个元组序列。</li><li><code>enumerate()</code>: 返回一个枚举对象，包含可迭代对象的索引和值。</li><li><code>map()</code>: 对可迭代对象的每个元素应用给定函数，并返回一个结果列表。</li><li><code>filter()</code>: 根据给定函数的返回值筛选可迭代对象中的元素，并返回一个结果列表。</li><li><code>open()</code>: 打开文件并返回文件对象。</li><li><code>help()</code>: 提供对象的帮助信息。</li><li><code>exit()</code>: 终止程序的执行。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数(中)</title>
      <link href="/post/694e35cb.html"/>
      <url>/post/694e35cb.html</url>
      
        <content type="html"><![CDATA[<h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域规定了在程序中某个位置定义的变量在哪些地方可以被引用。</p><ul><li><p>全局作用域：全局作用域是在整个程序中都可访问的作用域。在函数外部定义的变量属于全局作用域。全局作用域中的变量可以在程序的任何地方被引用。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">10</span>  <span class="comment"># 全局变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    <span class="built_in">print</span>(x)  <span class="comment"># 可以访问全局变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># 输出: 10</span></span><br></pre></td></tr></table></figure></li><li><p>局部作用域：局部作用域是在函数内部定义的作用域。在函数内部定义的变量属于局部作用域，只能在函数内部被访问。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">foo</span>():</span><br><span class="line">    y = <span class="number">20</span>  <span class="comment"># 局部变量</span></span><br><span class="line">    <span class="built_in">print</span>(y)  <span class="comment"># 可以访问局部变量</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">foo()  <span class="comment"># 输出: 20</span></span><br><span class="line"><span class="built_in">print</span>(y)  <span class="comment"># 报错，无法访问局部变量</span></span><br></pre></td></tr></table></figure></li><li><p>嵌套作用域：嵌套作用域是指在函数内部可以访问外部函数定义的变量。每当创建一个新的函数，就会创建一个新的嵌套作用域。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">outer</span>():</span><br><span class="line">    a = <span class="number">10</span>  <span class="comment"># 外部函数的局部变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">inner</span>():</span><br><span class="line">        b = <span class="number">20</span>  <span class="comment"># 内部函数的局部变量</span></span><br><span class="line">        <span class="built_in">print</span>(a + b)  <span class="comment"># 可以访问外部函数的变量</span></span><br><span class="line"></span><br><span class="line">    inner()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">outer()  <span class="comment"># 输出: 30</span></span><br></pre></td></tr></table></figure></li><li><p>内置作用域：内置作用域是指Python解释器内置的一些函数和变量的作用域。这些函数和变量可以直接在Python代码中使用，无需导入任何模块。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="built_in">len</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]))  <span class="comment"># 使用内置函数len()</span></span><br></pre></td></tr></table></figure></li></ul><p>在Python中，变量的作用域遵循 LEGB 原则，即在查找变量时按照以下顺序进行搜索：局部作用域（Local Scope） -&gt; 嵌套作用域（Enclosing Scope） -&gt; 全局作用域（Global Scope） -&gt; 内置作用域（Built-in Scope）。也就是说，如果在局部作用域找不到变量，就会向上一层作用域继续查找，直到找到为止。如果在所有作用域中都找不到变量，则会抛出 NameError 异常。</p><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><p>迭代是指重复执行某个操作的过程，并且每次迭代得到的结果会作为下一次迭代的初始值。</p><p>可迭代对象：从语法形式上讲，内置有<code>__iter__</code>方法的对象都是可迭代对象，字符串、列表、元组、字典、集合都是可迭代对象。</p><p>调用<code>__iter__</code>方法返回的结果就是一个迭代器对象(Iterator)。迭代器对象是内置有<code>__iter__</code>和<code>__next__</code>方法的对象</p><ul><li>执行迭代器对象<code>__iter__</code>方法得到的仍然是迭代器本身</li><li>而执行迭代器<code>__next__</code>方法就会计算出迭代器中的下一个值。</li></ul><p>for循环原理</p><ul><li><code>for</code> 循环是一种迭代循环，用于遍历可迭代对象中的元素。</li><li><code>for</code> 循环语法中的<code>in</code>后可以跟任何可迭代对象，如列表、元组、字符串、字典等。</li><li>当<code>for</code>循环开始执行时，它会首先调用可迭代对象的内置 <code>__iter__</code> 方法，以获取一个迭代器对象。</li><li>然后，<code>for</code>循环会重复调用迭代器对象的 <code>__next__</code> 方法，以获取可迭代对象中的下一个值，并将这个值赋给循环变量。</li><li>这个过程会一直重复，直到迭代器对象耗尽，即可迭代对象中的所有元素都被访问完毕，或者遇到<code>break</code>语句提前终止循环。</li><li>当迭代器对象耗尽时，它会引发 <code>StopIteration</code> 异常，这时<code>for</code>循环会捕捉到该异常，结束迭代过程。</li></ul><p>迭代器提供了一种统一的遍历方式，无论是对列表、字典、集合还是自定义的可迭代对象，都可以使用相同的 <code>for</code> 循环语法进行遍历。</p><h2 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h2><p>若函数体包含yield关键字，再调用函数，并不会执行函数体代码，得到的返回值即生成器对象，生成器内置有<code>__iter__</code>和<code>__next__</code>方法，所以生成器本身就是一个迭代器。我们可以用<code>__next__</code>触发生成器所对应函数的执行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">my_range</span>(<span class="params">start, stop, step=<span class="number">1</span></span>):</span><br><span class="line">    <span class="keyword">while</span> start &lt; stop:</span><br><span class="line">        <span class="keyword">yield</span> start</span><br><span class="line">        start += step</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">g = my_range(<span class="number">0</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure><p>有了yield关键字，我们就有了一种自定义迭代器的实现方式。yield可以用于返回值，但不同于return，函数一旦遇到return就结束了，而yield可以保存函数的运行状态挂起函数，用来返回多次值。</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><p>构成闭包函数的基本条件</p><ul><li>必须有一个内嵌函数：闭包函数需要在其内部定义一个或多个函数，这些内部函数被称为内嵌函数或嵌套函数。</li><li>内嵌函数必须引用外部函数中的变量：闭包函数的内嵌函数必须引用外部函数中的变量。这意味着内嵌函数可以访问和操作外部函数的变量，并且这些变量的状态在内嵌函数被调用时保留。</li><li>外部函数返回值必须是内嵌函数：外部函数需要返回其内部定义的内嵌函数。这样，外部函数调用后返回的是内嵌函数本身，而不是执行内嵌函数的结果。</li></ul><p>满足这三个要素的函数就是一个闭包函数。闭包可以被视为一种封装机制。封装是面向对象编程中的一个重要概念，它允许将数据和相关的操作封装在一个单元中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">counter</span>():</span><br><span class="line">    count = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">increment</span>():</span><br><span class="line">        <span class="keyword">nonlocal</span> count</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        <span class="built_in">print</span>(<span class="string">&quot;Count:&quot;</span>, count)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> increment</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">counter1 = counter()</span><br><span class="line">counter1()</span><br><span class="line">counter1()</span><br></pre></td></tr></table></figure><p><code>global</code> 语句：在函数内部修改全局变量；在函数内部定义全局变量（全局声明）。当你在函数内部使用 <code>global</code> 语句来修改一个变量时，Python 将会将该变量视为全局变量，而非局部变量。这样，你就可以在函数内部修改全局变量的值，而不会创建一个新的局部变量。</p><p><code>nonlocal</code> 语句：在内层函数中修改外层嵌套函数内的变量。当你在一个嵌套函数内部使用 <code>nonlocal</code> 语句来引用一个变量时，Python 将会将该变量视为来自于最近的非全局作用域，而非局部作用域。</p><h2 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h2><p>装饰器允许在不修改原始函数代码的情况下，通过包装函数来扩展或修改其行为。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">timer_decorator</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">        start_time = time.time()</span><br><span class="line">        result = func(*args, **kwargs)</span><br><span class="line">        end_time = time.time()</span><br><span class="line">        execution_time = end_time - start_time</span><br><span class="line">        <span class="built_in">print</span>(<span class="string">f&quot;Function &#x27;<span class="subst">&#123;func.__name__&#125;</span>&#x27; executed in <span class="subst">&#123;execution_time&#125;</span> seconds.&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@timer_decorator</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">my_function</span>():</span><br><span class="line">    <span class="comment"># 模拟函数执行</span></span><br><span class="line">    time.sleep(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用被装饰的函数</span></span><br><span class="line">my_function()</span><br></pre></td></tr></table></figure><p>通过在函数定义上方使用 <code>@timer_decorator</code>，我们将 <code>my_function</code> 函数应用了装饰器。这意味着在调用 <code>my_function()</code> 时，实际上是在调用装饰器返回的<code>wrapper</code>函数。这样，我们可以在不修改 <code>my_function</code> 的情况下，为其添加额外的行为（记录执行时间）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 装饰器模板</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">outter</span>(<span class="params">func</span>):</span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">wrapper</span>(<span class="params">*args,**kwargs</span>):</span><br><span class="line">        <span class="comment"># 1、调用原函数</span></span><br><span class="line">        <span class="comment"># 2、为其增加新功能</span></span><br><span class="line">        res=func(*args,**kwargs)</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python函数(上)</title>
      <link href="/post/b38b87ae.html"/>
      <url>/post/b38b87ae.html</url>
      
        <content type="html"><![CDATA[<p>函数是编程中用于封装特定功能的代码块，可以重复执行和调用。函数的定义有助于提高代码的可重用性和可维护性，使代码的结构更清晰。</p><h2 id="函数的定义"><a href="#函数的定义" class="headerlink" title="函数的定义"></a>函数的定义</h2><p>在Python中，函数的定义使用关键字<code>def</code>，其语法格式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">函数名</span>(<span class="params">形参</span>):</span><br><span class="line">    <span class="comment"># 函数体，实现特定功能的代码块</span></span><br></pre></td></tr></table></figure><ul><li><code>def</code> 关键字：<code>def</code> 是函数定义的关键字，全称为 “define”，用于定义一个函数。</li><li>函数名：函数名是用来唯一标识函数的名称，遵循变量命名的规则，用于在代码中调用函数。</li><li>形参：形参是函数中用于接收外部传入的值的变量，也称为函数的输入。形式参数可以有零个或多个，多个参数之间使用逗号<code>,</code>分隔。</li><li>函数体：函数体是实现函数功能的代码块，可以包含一条或多条语句。函数体通常使用缩进来表示代码块的范围。</li></ul><h2 id="函数的调用"><a href="#函数的调用" class="headerlink" title="函数的调用"></a>函数的调用</h2><p>函数的调用是指执行函数体中的代码，实现函数定义中所描述的功能。</p><p>在函数定义阶段，只是定义了函数的结构和参数，而不会执行函数体中的代码。这样可以在之后的任何时候通过函数名进行调用，以便执行函数体中的代码。</p><p>函数的调用发生在函数名后跟随的括号中，括号中可以包含传递给函数的实际参数。当函数被调用时，传递的实际参数会被赋值给函数定义中的形式参数，然后函数体中的代码会被执行。</p><p>这种分离定义和调用的机制使得函数可以在需要时多次调用，实现代码的重复利用。通过函数的调用，我们可以使用定义好的函数工具来执行特定的功能。</p><h2 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h2><p>在函数中，可以使用<code>return</code>语句指定应该返回的值。如果没有显式使用<code>return</code>语句，函数默认返回<code>None</code>。</p><p><code>None</code>是Python中表示空值的特殊对象。它是<code>NoneType</code>数据类型的唯一值，用于表示没有值的情况。在函数中，如果没有指定返回值或直接省略<code>return</code>语句，函数将隐式返回<code>None</code>。</p><p>需要注意的是，在同一个函数中，一旦执行到一个<code>return</code>语句，函数的执行将立即结束，并且后续的代码将被忽略。因此，如果函数包含多个<code>return</code>语句，只有第一个被执行到的<code>return</code>语句之后的代码将被忽略。</p><h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>Python函数可以接受不同类型的参数，包括必需参数、关键字参数、默认参数和可变参数。</p><ul><li><p>必需参数：必需参数是在函数定义中按照顺序声明的参数。在调用函数时，必须按照相同的顺序传递参数值。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">add</span>(<span class="params">x, y</span>):</span><br><span class="line">    <span class="keyword">return</span> x + y</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = add(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li><p>关键字参数：关键字参数是在函数调用时使用参数名和值进行传递的参数。这样可以不考虑参数的顺序，只需指定参数名及对应的值。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">greet</span>(<span class="params">name, message</span>):</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f&quot;Hello, <span class="subst">&#123;name&#125;</span>! <span class="subst">&#123;message&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">greet(name=<span class="string">&quot;Alice&quot;</span>, message=<span class="string">&quot;How are you?&quot;</span>)</span><br><span class="line">greet(message=<span class="string">&quot;Nice to meet you!&quot;</span>, name=<span class="string">&quot;Bob&quot;</span>)</span><br></pre></td></tr></table></figure><p>  注意：在调用函数时，实参也可以是按必须或按关键字的混合使用，但必须保证关键字参数在位置参数后面。</p></li><li><p>默认参数：默认参数是在函数定义时为参数提供默认值。如果在函数调用时没有为该参数提供值，则使用默认值。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">power</span>(<span class="params">base, exponent=<span class="number">2</span></span>):</span><br><span class="line">    <span class="keyword">return</span> base ** exponent</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result1 = power(<span class="number">3</span>)</span><br><span class="line">result2 = power(<span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure><p>  注意：默认参数必须在必须参数之后。</p></li><li><p>可变参数：在Python中，有两种类型的可变参数：*args 和 **kwargs。它们允许函数接受可变数量的参数。可以用在函数的形参和实参中。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># *args和**kwargs可以在函数的形参中使用，以接收可变数量的位置参数和关键字参数。</span></span><br><span class="line"><span class="comment"># *args用于接收位置参数，它将传递给函数的所有位置参数作为一个元组。</span></span><br><span class="line"><span class="comment"># **kwargs用于接收关键字参数，它将传递给函数的所有关键字参数作为一个字典。</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">*args, **kwargs</span>):</span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">print</span>(arg)</span><br><span class="line">    <span class="keyword">for</span> key, value <span class="keyword">in</span> kwargs.items():</span><br><span class="line">        <span class="built_in">print</span>(key, value)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">func(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, name=<span class="string">&#x27;John&#x27;</span>, age=<span class="number">25</span>)</span><br><span class="line"></span><br></pre></td></tr></table></figure>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 在函数调用时，我们可以使用 * 和 ** 运算符对可迭代对象进行解包，将其元素作为可变参数传递给函数。</span></span><br><span class="line"><span class="comment"># *args解包的是一个可迭代对象，它会将可迭代对象的元素作为位置参数传递给函数。</span></span><br><span class="line"><span class="comment"># **kwargs 解包的是一个字典，它会将字典的键值对作为关键字参数传递给函数。</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">func</span>(<span class="params">a, b, c</span>):</span><br><span class="line">    <span class="built_in">print</span>(a, b, c)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">my_dict = &#123;<span class="string">&#x27;a&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;b&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;c&#x27;</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">func(*my_list)  <span class="comment"># 输出: 1 2 3</span></span><br><span class="line">func(**my_dict)  <span class="comment"># 输出: 1 2 3</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型-字典与集合</title>
      <link href="/post/23e8ad99.html"/>
      <url>/post/23e8ad99.html</url>
      
        <content type="html"><![CDATA[<h2 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h2><p>字典（<code>dict</code>）被称为映射类型是因为它提供了键-值对的映射关系。</p><p>在字典中，每个键（key）都是唯一的，并且与一个对应的值（value）相关联。这种键和值之间的映射关系使得字典非常适合用于存储和查找基于键的数据。字典使用花括号 <code>&#123;&#125;</code> 来创建，每个键值对之间使用冒号 <code>:</code> 分隔，键和值之间使用逗号 <code>,</code> 分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建一个字典</span></span><br><span class="line">person = &#123;<span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Alice&#x27;</span>, <span class="string">&#x27;age&#x27;</span>: <span class="number">30</span>, <span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;New York&#x27;</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问字典中的值</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&#x27;name&#x27;</span>]) </span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改字典中的值</span></span><br><span class="line">person[<span class="string">&#x27;age&#x27;</span>] = <span class="number">31</span></span><br><span class="line"><span class="built_in">print</span>(person[<span class="string">&#x27;age&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加新的键值对</span></span><br><span class="line">person[<span class="string">&#x27;gender&#x27;</span>] = <span class="string">&#x27;female&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除键值对</span></span><br><span class="line"><span class="keyword">del</span> person[<span class="string">&#x27;city&#x27;</span>]</span><br><span class="line"><span class="built_in">print</span>(person)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查键是否存在</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;name&#x27;</span> <span class="keyword">in</span> person)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;city&#x27;</span> <span class="keyword">in</span> person)</span><br></pre></td></tr></table></figure><p>字典的特点包括：</p><ol><li>字典中的键必须是不可变的（例如字符串、数字或元组），而值可以是任意类型的数据。</li><li>每个键在字典中是唯一的，不会重复。如果尝试使用相同的键插入新的值，会更新该键对应的值。</li><li>字典是可变的，可以通过添加、删除或修改键值对来改变字典的内容。</li></ol><p>获取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123; <span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,  <span class="string">&quot;k2&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line">result = data.get(<span class="string">&quot;k1&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>获取所有的键</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123; <span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,  <span class="string">&quot;k2&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line">result = data.keys()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>获取所有的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123; <span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,  <span class="string">&quot;k2&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line">result = data.values()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>获取所有的键值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = &#123; <span class="string">&quot;k1&quot;</span>:<span class="number">1</span>,  <span class="string">&quot;k2&quot;</span>:<span class="number">2</span> &#125;</span><br><span class="line">result = data.items()</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure><p>设置值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># key不存在则新增键值对，并将新增的value返回</span></span><br><span class="line">data = &#123;</span><br><span class="line">    <span class="string">&quot;email&quot;</span>: <span class="string">&#x27;xxx@qq.com&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line">data.setdefault(<span class="string">&quot;age&quot;</span>, <span class="number">18</span>)</span><br><span class="line"><span class="built_in">print</span>(data)</span><br></pre></td></tr></table></figure><p>更新字典键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 用新字典更新旧字典，有则修改，无则添加</span></span><br><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>&#125;</span><br><span class="line">info.update(&#123;<span class="string">&quot;age&quot;</span>:<span class="number">14</span>,<span class="string">&quot;name&quot;</span>:<span class="string">&quot;哈哈哈&quot;</span>&#125;)</span><br><span class="line"><span class="built_in">print</span>(info) </span><br></pre></td></tr></table></figure><p>移除指定键值对</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">info = &#123;<span class="string">&quot;age&quot;</span>:<span class="number">12</span>, <span class="string">&quot;status&quot;</span>:<span class="literal">True</span>&#125;</span><br><span class="line">data = info.pop(<span class="string">&quot;age&quot;</span>)</span><br><span class="line"><span class="built_in">print</span>(info)</span><br></pre></td></tr></table></figure><p>关于dict()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过键值对参数创建字典</span></span><br><span class="line">person = <span class="built_in">dict</span>(name=<span class="string">&#x27;Alice&#x27;</span>, age=<span class="number">30</span>, city=<span class="string">&#x27;New York&#x27;</span>)</span><br><span class="line"><span class="built_in">print</span>(person) </span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过可迭代对象创建字典：</span></span><br><span class="line">items = [(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;Alice&#x27;</span>), (<span class="string">&#x27;age&#x27;</span>, <span class="number">30</span>), (<span class="string">&#x27;city&#x27;</span>, <span class="string">&#x27;New York&#x27;</span>)]</span><br><span class="line">person = <span class="built_in">dict</span>(items)</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>在Python中，集合（Set）是一种无序且不重复的数据集合。它是由一组唯一的元素组成，其中每个元素在集合中只能出现一次。集合是可变的，可以添加、删除和修改元素。</p><p>可以使用花括号 <code>&#123;&#125;</code> 或者 <code>set()</code> 函数来创建集合。如果使用花括号创建集合，元素直接用逗号 <code>,</code> 分隔。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fruits = &#123;<span class="string">&#x27;apple&#x27;</span>, <span class="string">&#x27;banana&#x27;</span>, <span class="string">&#x27;orange&#x27;</span>&#125;</span><br><span class="line">empty_set = <span class="built_in">set</span>()</span><br></pre></td></tr></table></figure><p>添加元素：使用 <code>add()</code> 方法可以向集合中添加单个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits.add(<span class="string">&#x27;grape&#x27;</span>)</span><br></pre></td></tr></table></figure><p>移除元素：使用<code>remove()</code>或者 <code>discard()</code> 方法可以从集合中移除元素。如果元素不存在，<code>remove()</code>方法会引发KeyError异常，而<code>discard()</code>方法则不会引发异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruits.remove(<span class="string">&#x27;banana&#x27;</span>)</span><br></pre></td></tr></table></figure><p>集合操作：可以使用集合操作符对集合进行操作。</p><ul><li><p>交集（intersection）是集合操作中的一种，表示两个或多个集合中共同存在的元素的集合。在Python中，可以使用符号 <code>&amp;</code> 或者 <code>intersection()</code> 方法来计算集合的交集。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s3 = s1 &amp; s2  <span class="comment"># 使用 &amp; 符号计算交集</span></span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;2, 3&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 intersection() 方法</span></span><br><span class="line">s3 = s1.intersection(s2)</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;2, 3&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>在集合运算中，”并集”（union）指的是将两个或多个集合中的所有元素合并成一个集合，且集合中的元素不重复。在Python中，可以使用符号 <code>|</code> 或者 <code>union()</code> 方法来计算集合的并集。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s3 = s1 | s2  <span class="comment"># 使用 | 符号计算并集</span></span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;1, 2, 3, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 union() 方法</span></span><br><span class="line">s3 = s1.union(s2)</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;1, 2, 3, 4&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>差集（difference）是集合操作中的一种，表示从一个集合中去除与另一个集合中共同存在的元素，得到剩余的元素的集合。在Python中，可以使用符号 <code>-</code> 或者 <code>difference()</code> 方法来计算集合的差集。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s3 = s1 - s2  <span class="comment"># 使用 - 符号计算差集</span></span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;1&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 difference() 方法</span></span><br><span class="line">s3 = s1.difference(s2)</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;1&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>对称差集（symmetric difference）是集合操作中的一种，表示两个集合中不重复的元素的集合。在Python中，可以使用符号 <code>^</code> 或者 <code>symmetric_difference()</code> 方法来计算集合的对称差集。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;</span><br><span class="line">s2 = &#123;<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line">s3 = s1 ^ s2  <span class="comment"># 使用 ^ 符号计算对称差集</span></span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;1, 4&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 或者使用 symmetric_difference() 方法</span></span><br><span class="line">s3 = s1.symmetric_difference(s2)</span><br><span class="line"><span class="built_in">print</span>(s3)  <span class="comment"># 输出: &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据类型-序列</title>
      <link href="/post/f85dc389.html"/>
      <url>/post/f85dc389.html</url>
      
        <content type="html"><![CDATA[<h2 id="序列介绍"><a href="#序列介绍" class="headerlink" title="序列介绍"></a>序列介绍</h2><p>在Python中，序列是一种有序的数据集合。常见的序列类型包括字符串、列表、元组。这些序列类型具有一些共同的特性和操作。</p><p>序列类型都支持共同的操作：</p><ul><li>索引访问：使用索引来获取序列中的单个元素，如<br>  <code>sequence[index]</code>。</li><li>切片操作：使用切片来获取序列中的子序列，如<br>  <code>sequence[start:end:step]</code>。</li><li>长度获取：使用内置函数<code>len()</code>来获取序列的长度，如<br>  <code>len(sequence)</code>。</li><li>成员检查：使用关键字<code>in</code>来检查一个元素是否存在于序列中，如<br>  <code>element in sequence</code>。</li><li>连接操作：使用加号<code>+</code>来连接两个序列，生成一个新的序列，如<br>  <code>sequence1 + sequence2</code>。</li><li>重复操作：使用乘号<code>*</code>来重复序列中的元素，生成一个新的序列，如<br>  <code>sequence * n</code>。</li><li>迭代：使用<code>for</code>循环来遍历序列中的元素，如<br>  <code>for element in sequence:</code>。</li><li>元素查找：使用<code>index()</code>方法来查找指定元素在序列中的索引。如果元素不存在，会引发<code>ValueError</code>错误。如<br>  <code>sequence.index(&quot;3&quot;)</code>。</li><li>计数元素出现次数：使用<code>count()</code>方法来统计指定元素在序列中出现的次数。如<br>  <code>sequence.count(&quot;2&quot;)</code>.</li><li>最值获取：使用内置函数<code>max()</code>和<code>min()</code>来获取序列中的最大值和最小值，如<br>  <code>max(sequence)</code>和<code>min(sequence)</code>。</li><li>排序操作：使用内置函数<code>sorted()</code>对序列进行排序，生成一个新的排序后的序列，如<br>  <code>sorted(sequence)</code>。</li></ul><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="字符串格式化"><a href="#字符串格式化" class="headerlink" title="字符串格式化"></a>字符串格式化</h3><p>字符串格式化是一种在字符串中插入变量或值的方法，以便根据特定的格式要求创建最终的字符串。在Python中，有多种方法可以进行字符串格式化，包括：</p><ul><li>使用百分号（%）格式化字符串：这是一种传统的字符串格式化方法，在字符串中使用百分号作为占位符，并使用对应的值进行替换。</li><li>使用<code>str.format()</code>方法进行格式化：这是一种更灵活的字符串格式化方法，通过在字符串中使用花括号{}作为占位符，并使用<code>format()</code>方法来进行值的替换。</li><li>使用f-strings：这是Python 3.6及更高版本引入的一种方便的字符串格式化方法。它允许在字符串前加上字母”f”，并在字符串中使用花括号{}来插入变量或表达式的值。</li></ul><h3 id="内置方法"><a href="#内置方法" class="headerlink" title="内置方法"></a>内置方法</h3><p>我们在开发程序时需要频繁对数据进行操作，为了提升我们的开发效率， python针对这些常用的操作，为每一种数据类型内置了一系列方法。</p><ul><li><code>startswith()</code>: 检查字符串是否以指定的子字符串开头，返回布尔值。<br>  例如：<code>&quot;Hello&quot;.startswith(&quot;He&quot;)</code> 返回 <code>True</code>。</li><li><code>endswith()</code>: 检查字符串是否以指定的子字符串结尾，返回布尔值。<br>  例如：<code>&quot;Hello&quot;.endswith(&quot;lo&quot;)</code> 返回 <code>True</code>。</li><li><code>isdigit()</code>: 检查字符串是否只包含数字字符，返回布尔值。<br>  例如：<code>&quot;123&quot;.isdigit()</code> 返回 <code>True</code>。</li><li><code>strip()</code>: 去除字符串两端的空格（或指定的字符）。<br>  例如：<code>&quot;  hello  &quot;.strip()</code> 返回 “hello”。</li><li><code>lower()</code>: 将字符串转换为小写形式。<br>  例如：<code>&quot;Hello&quot;.lower()</code> 返回 “hello”。</li><li><code>upper()</code>: 将字符串转换为大写形式。<br>  例如：<code>&quot;Hello&quot;.upper()</code> 返回 “HELLO”。</li><li><code>replace()</code>: 将字符串中的指定子字符串替换为新的字符串。<br>  例如：<code>&quot;Hello&quot;.replace(&quot;H&quot;, &quot;J&quot;)</code> 返回 “Jello”。</li><li><code>find()</code>: 查找指定子字符串在字符串中的索引位置，如果找到返回索引值，否则返回-1。例如：<code>&quot;Hello&quot;.find(&quot;l&quot;)</code> 返回 2。</li><li><code>split()</code>: 将字符串按照指定的分隔符分割成子字符串，并返回一个包含子字符串的列表。<br>  例如：<code>&quot;Hello,World&quot;.split(&quot;,&quot;)</code> 返回 <code>[&quot;Hello&quot;, &quot;World&quot;]</code>。</li><li><code>join()</code>: 将一个包含字符串的可迭代对象（如列表）连接成一个字符串，使用指定的连接符。<br>  例如：<code>&quot;-&quot;.join([&quot;Hello&quot;, &quot;World&quot;])</code> 返回 “Hello-World”。</li></ul><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>在Python中，列表（List）是一种常用的数据类型，是一个有序且可变的容器，在里面可以存放多个不同类型的元素。列表会将所有元素都放在一对中括号<code>[ ]</code>里面，相邻元素之间用逗号<code>,</code>分隔。建议在列表中放置相同类型的数据，这样可以提高代码的可读性和维护性。</p><ul><li>字符串是不可变的，一旦创建后，字符串的内容就无法更改。这意味着对字符串的操作（如拼接、切片、替换等）都会生成一个新的字符串对象，而不会修改原始字符串。这是由于字符串的不可变性质决定的。</li><li>列表是可变的，可以在创建后修改其中的元素。列表提供了许多内置方法和操作符，可以直接在列表上进行添加、删除、修改和重排序等操作，而无需创建新的列表对象。</li></ul><h3 id="内置方法-1"><a href="#内置方法-1" class="headerlink" title="内置方法"></a>内置方法</h3><p>列表添加元素</p><ul><li><code>append(item)</code>: 在列表末尾添加一个元素。</li><li><code>extend(iterable)</code>: 将可迭代对象中的元素逐个添加到列表末尾。</li><li><code>insert(index, item)</code>: 在指定索引位置插入一个元素。</li></ul><p>列表删除元素</p><ul><li><code>remove(item)</code>: 删除列表中第一个匹配的元素。</li><li><code>pop(index)</code>: 删除并返回指定索引位置的元素。如果没有指定索引，默认删除并返回最后一个元素。</li><li><code>clear()</code>:清空列表中的所有元素，使列表变为空列表。</li></ul><p>列表元素排序</p><ul><li><code>sort()</code>: 对列表进行排序（默认升序）。</li><li><code>reverse()</code>: 反转列表中的元素顺序。</li></ul><h3 id="列表推导式"><a href="#列表推导式" class="headerlink" title="列表推导式"></a>列表推导式</h3><p>列表推导式根据特定的条件对元素进行筛选、转换。列表推导式的一般形式如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_list = [expression <span class="keyword">for</span> item <span class="keyword">in</span> iterable <span class="keyword">if</span> condition]</span><br></pre></td></tr></table></figure><ul><li><code>expression</code> 是一个表达式，用于定义新列表中的元素。</li><li><code>item</code> 是迭代过程中的每个元素。</li><li><code>iterable</code> 是一个可迭代对象，例如列表、字符串、元组等。</li><li><code>condition</code> 是一个可选的条件，用于筛选元素，只有满足条件的元素才会被包含在新列表中。</li></ul><h2 id="元组"><a href="#元组" class="headerlink" title="元组"></a>元组</h2><p>元组（tuple），是一个有序且不可变的容器，在里面可以存放多个不同类型的元素。</p><p>使用 ( ) 直接创建，当创建的元组中只有一个字符串类型的元素时，该元素后面必须要加一个逗号。</p><p>如果你使用逗号 <code>,</code> 分隔多个值并将它们赋值给一个变量，Python 会将这些值打包成一个元组。</p>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>流程控制</title>
      <link href="/post/368ebfeb.html"/>
      <url>/post/368ebfeb.html</url>
      
        <content type="html"><![CDATA[<p>程序有3种结构：顺序结构、分支结构和循环结构。若是在程序中没有给出特别的执行目标，则默认自上而下一行一行地执行该程序，这类程序的结构就称为顺序结构。之前我们写的代码都是顺序结构。</p><h2 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h2><p>分支结构是流程控制中的一种形式，用于根据条件的真假选择不同的执行路径。在分支结构中，程序根据条件的结果执行不同的代码块。可分为单分支、双分支、多分支。</p><h3 id="单分支结构"><a href="#单分支结构" class="headerlink" title="单分支结构"></a>单分支结构</h3><p>单分支结构是最简单的分支结构形式，它只有一个条件，根据条件的结果选择是否执行特定的代码块。当条件为真时，执行相应的代码块；当条件为假时，跳过代码块继续执行后续代码。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件为真时执行的代码块</span><br></pre></td></tr></table></figure><ul><li>代码块由具由相同缩进量的若干条语句组成。<ul><li>缩进通常使用四个空格或一个制表符进行。</li><li>在同一个代码块中，所有的语句必须具有相同的缩进级别。</li></ul></li><li>if语句的最后要有有冒号<code>:</code>，不要忘记。</li></ul><h3 id="双分支结构"><a href="#双分支结构" class="headerlink" title="双分支结构"></a>双分支结构</h3><p>双分支结构有两个分支路径，根据条件的真假选择不同的执行路径。当条件为真时，执行一个代码块；当条件为假时，执行另一个代码块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件:</span><br><span class="line">    条件为真时执行的代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    条件为假时执行的代码块</span><br></pre></td></tr></table></figure><h3 id="多分支结构"><a href="#多分支结构" class="headerlink" title="多分支结构"></a>多分支结构</h3><p>多分支结构有多个分支路径，根据不同的条件结果选择不同的执行路径。条件逐个进行判断，一旦有条件为真，执行相应的代码块并跳过剩余的条件判断。如果所有条件都为假，则执行else代码块（可选）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    条件<span class="number">1</span>为真时执行的代码块</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">2</span>:</span><br><span class="line">    条件<span class="number">2</span>为真时执行的代码块</span><br><span class="line"><span class="keyword">elif</span> 条件<span class="number">3</span>:</span><br><span class="line">    条件<span class="number">3</span>为真时执行的代码块</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    所有条件都为假时执行的代码块</span><br></pre></td></tr></table></figure><ul><li>elif可以有0个或多个。</li><li>else可以有0个或1个，且只能放在if语句的最后。</li></ul><p>条件可以是一个单一的值或者变量，也可以是由运算符组成的复杂语句。不管条件的结果是什么类型。if 都能判断它是否成立（真或者假）</p><h3 id="if语句的嵌套"><a href="#if语句的嵌套" class="headerlink" title="if语句的嵌套"></a>if语句的嵌套</h3><p>在Python中，可以使用if语句的嵌套来实现根据多个条件进行判断和执行不同的代码块。if嵌套的语法结构如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> 条件<span class="number">1</span>:</span><br><span class="line">    <span class="comment"># 执行条件1为真时的代码块</span></span><br><span class="line">    <span class="keyword">if</span> 条件<span class="number">2</span>:</span><br><span class="line">        <span class="comment"># 执行条件2为真时的代码块</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># 执行条件2为假时的代码块</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 执行条件1为假时的代码块</span></span><br></pre></td></tr></table></figure><p>在if块中，可以再次嵌套一个if语句作为条件2。这样可以根据条件1和条件2的结果进行更复杂的判断。</p><h3 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h3><p>条件表达式也被称为三元运算符，它提供了一种简洁的方式来根据条件选择不同的值或执行不同的表达式。</p><p>条件表达式的语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">value_if_true <span class="keyword">if</span> condition <span class="keyword">else</span> value_if_false</span><br></pre></td></tr></table></figure><p>在这个结构中，首先评估条件。如果条件为真，则返回value_if_true；如果条件为假，则返回value_if_false。</p><h2 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h2><p>Python中的循环语句用于重复执行一段代码块，直到满足特定的条件为止。Python提供了两种主要的循环语句：for循环和while循环。</p><h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>while循环根据条件的真假来重复执行代码块，直到条件为假为止。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> 条件:</span><br><span class="line">    循环体代码块</span><br></pre></td></tr></table></figure><p>while循环执行的具体流程：</p><ol><li>首先，判断条件是否为真（True）。</li><li>如果条件为真，则执行循环体中的代码块。</li><li>执行完循环体中的代码后，再次回到步骤1。</li><li>如果条件仍为真，则继续执行循环体中的代码，然后再次回到步骤1。</li><li>这个过程会一直重复，直到条件为假（False）。</li></ol><p><strong>循环中止语句</strong></p><p>如果在循环的过程中，因为某些原因，你不想继续循环了，怎么把它中止掉呢？这就用到break或continue语句。</p><ul><li>break用于完全结束一个循环，跳出循环体执行循环后面的语句</li><li>continue和break有点类似，区别在于continue只是终止本次循环，接着还执行后面的循环，break则完全终止循环</li></ul><p><strong>while … else ..</strong></p><p>while 后面的else作用是指，<strong>当while 循环正常执行完，中间没有被break 中止的话，就会执行else后面的语句</strong>。</p><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>循环结构的第二种实现方式是for循环，for循环可以做的事情while循环都可以实现，之所以用for循环是因为在循环取值时for循环比while循环的使用更为简洁。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 简单版：for循环的实现方式</span></span><br><span class="line"><span class="keyword">for</span> count <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">6</span>): </span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 复杂版：while循环的实现方式</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span> count &lt; <span class="number">6</span>:</span><br><span class="line">    <span class="built_in">print</span>(count)</span><br><span class="line">    count += <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><p>break 与 continue也可以用于for循环，使用语法同while循环</p></li><li><p>for…else.. 与 while … else ..同理</p></li><li><p>range，帮助我们创建一系列的数字</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># range(开始点，结束点，间隔)</span></span><br><span class="line"><span class="comment"># 返回的数字不包含结束点</span></span><br><span class="line"><span class="comment"># 开始点默认为0，间隔默认值为1 。</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">10</span>)  <span class="comment"># 0,1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>)  <span class="comment"># 1,2,3,4,5,6,7,8,9</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">1</span>,<span class="number">10</span>,<span class="number">2</span>)  <span class="comment"># 1,3,5,7,9</span></span><br><span class="line"><span class="built_in">range</span>(<span class="number">10</span>,<span class="number">1</span>,-<span class="number">1</span>)  <span class="comment"># 10,9,8,7,6,5,4,3,2</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>运算符</title>
      <link href="/post/f29265a7.html"/>
      <url>/post/f29265a7.html</url>
      
        <content type="html"><![CDATA[<h2 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">说明</th><th align="center">实例</th><th align="center">结果</th></tr></thead><tbody><tr><td align="center">+</td><td align="center">加</td><td align="center">12.45 + 15</td><td align="center">27.45</td></tr><tr><td align="center">-</td><td align="center">减</td><td align="center">4.56 - 0.26</td><td align="center">4.3</td></tr><tr><td align="center">*</td><td align="center">乘</td><td align="center">5 * 3.6</td><td align="center">18.0</td></tr><tr><td align="center">&#x2F;</td><td align="center">除法（和数学中的规则一样）</td><td align="center">7 &#x2F; 2</td><td align="center">3.5</td></tr><tr><td align="center">&#x2F;&#x2F;</td><td align="center">整除（只保留商的整数部分）</td><td align="center">7 &#x2F;&#x2F; 2</td><td align="center">3</td></tr><tr><td align="center">%</td><td align="center">取余，即返回除法的余数</td><td align="center">7 % 2</td><td align="center">1</td></tr><tr><td align="center">**</td><td align="center">幂运算&#x2F;次方运算，即返回 x 的 y 次方</td><td align="center">2 ** 4</td><td align="center">16，即 2^4^</td></tr></tbody></table><h2 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h2><table><thead><tr><th align="center">运算符</th><th align="center">说 明</th><th align="center">用法举例</th><th align="center">等价形式</th></tr></thead><tbody><tr><td align="center">&#x3D;</td><td align="center">最基本的赋值运算</td><td align="center">x &#x3D; y</td><td align="center">x &#x3D; y</td></tr><tr><td align="center">+&#x3D;</td><td align="center">加赋值</td><td align="center">x +&#x3D; y</td><td align="center">x &#x3D; x + y</td></tr><tr><td align="center">-&#x3D;</td><td align="center">减赋值</td><td align="center">x -&#x3D; y</td><td align="center">x &#x3D; x - y</td></tr><tr><td align="center">*&#x3D;</td><td align="center">乘赋值</td><td align="center">x *&#x3D; y</td><td align="center">x &#x3D; x * y</td></tr><tr><td align="center">&#x2F;&#x3D;</td><td align="center">除赋值</td><td align="center">x &#x2F;&#x3D; y</td><td align="center">x &#x3D; x &#x2F; y</td></tr><tr><td align="center">%&#x3D;</td><td align="center">取余数赋值</td><td align="center">x %&#x3D; y</td><td align="center">x &#x3D; x % y</td></tr><tr><td align="center">**&#x3D;</td><td align="center">幂赋值</td><td align="center">x **&#x3D; y</td><td align="center">x &#x3D; x ** y</td></tr><tr><td align="center">&#x2F;&#x2F;&#x3D;</td><td align="center">取整数赋值</td><td align="center">x &#x2F;&#x2F;&#x3D; y</td><td align="center">x &#x3D; x &#x2F;&#x2F; y</td></tr></tbody></table><p>python语法中除了有&#x3D;号这种简单的赋值运算外，还支持增量赋值、链式赋值、交叉赋值。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将值赋值给变量</span></span><br><span class="line">n1 = <span class="number">100</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将一个变量的值赋给另一个变量</span></span><br><span class="line">n2 = n1</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将运算的值赋给变量</span></span><br><span class="line">sum1 = <span class="number">25</span> + <span class="number">46</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 增量赋值</span></span><br><span class="line">n1 += <span class="number">1</span>  <span class="comment"># n1 = n1 + 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 链式赋值:把同一个值同时赋值给多个变量名</span></span><br><span class="line">x = y = z = <span class="number">10</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 交叉赋值：将m与n的值交换过来</span></span><br><span class="line">m = <span class="number">10</span></span><br><span class="line">n = <span class="number">20</span></span><br><span class="line">m, n = n, m  <span class="comment"># 交叉赋值</span></span><br></pre></td></tr></table></figure><h2 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h2><table><thead><tr><th align="center">比较运算符</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">&gt;</td><td align="center">大于，如果<code>&gt;</code>前面的值大于后面的值，则返回 True，否则返回 False。</td></tr><tr><td align="center">&lt;</td><td align="center">小于，如果<code>&lt;</code>前面的值小于后面的值，则返回 True，否则返回 False。</td></tr><tr><td align="center">&#x3D;&#x3D;</td><td align="center">等于，如果<code>==</code>两边的值相等，则返回 True，否则返回 False。</td></tr><tr><td align="center">&gt;&#x3D;</td><td align="center">大于等于（等价于数学中的 ≥），如果<code>&gt;=</code>前面的值大于或者等于后面的值，则返回 True，否则返回 False。</td></tr><tr><td align="center">&lt;&#x3D;</td><td align="center">小于等于（等价于数学中的 ≤），如果<code>&lt;=</code>前面的值小于或者等于后面的值，则返回 True，否则返回 False。</td></tr><tr><td align="center">!&#x3D;</td><td align="center">不等于（等价于数学中的 ≠），如果<code>!=</code>两边的值不相等，则返回 True，否则返回 False。</td></tr><tr><td align="center">is</td><td align="center"><strong>x is y</strong>, 类似 <strong>id(x) &#x3D;&#x3D; id(y)</strong> , is比较的是id，id相同则返回True</td></tr><tr><td align="center">is not</td><td align="center"><strong>x is not y</strong> ， 类似 **id(a) !&#x3D; id(b)**。 id不同时is not会返回True</td></tr></tbody></table><p>&#x3D;&#x3D;双等号比较的是value是否相等，而is比较的是id是否相等</p><ul><li>id相同，内存地址必定相同，意味着type和value必定相同</li><li>value相同type肯定相同，但id可能不同</li></ul><p><strong>布尔类型：</strong>Python提供了bool类型来表示真（对）或假（错）</p><ul><li>5 &gt; 3这个是正确的，在程序世界里称之为真（对），Python中使用True来表示。</li><li>4 &gt; 20这个是错误的，在程序世界里称之为假（错），Python 使用 False 来代表。</li><li>常见的类型转换为bool类型的规则<ul><li>数字类型：0转换为False，非零数字转换为True。</li><li>空字符串(“”)转换为False，非空字符串转换为True。</li></ul></li></ul><h2 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h2><table><thead><tr><th align="center">逻辑运算符</th><th align="center">含义</th><th align="center">基本格式</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">and</td><td align="center">逻辑与运算，等价于数学中的“且”</td><td align="center">a and b</td><td align="center">当 a 和 b 两个表达式都为真时，a and b 的结果才为真，否则为假。</td></tr><tr><td align="center">or</td><td align="center">逻辑或运算，等价于数学中的“或”</td><td align="center">a or b</td><td align="center">当 a 和 b 两个表达式都为假时，a or b 的结果才是假，否则为真。</td></tr><tr><td align="center">not</td><td align="center">逻辑非运算，等价于数学中的“非”</td><td align="center">not a</td><td align="center">如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。</td></tr></tbody></table><p>在Python中，逻辑运算符支持短路运算。短路运算是一种特殊的逻辑运算，当结果已经可以确定时，就不再执行后续的表达式，从而提高程序的效率。</p><p><strong>短路与运算（<code>and</code>）：</strong></p><ul><li>如果第一个表达式为False，则整个表达式的结果为False，不再计算后续表达式。</li><li>如果第一个表达式为True，则继续计算后续表达式，最终结果取决于最后一个表达式。</li></ul><p><strong>短路或运算（<code>or</code>）：</strong></p><ul><li>如果第一个表达式为True，则整个表达式的结果为True，不再计算后续表达式。</li><li>如果第一个表达式为False，则继续计算后续表达式，最终结果取决于最后一个表达式。</li></ul><h2 id="运算符优先级"><a href="#运算符优先级" class="headerlink" title="运算符优先级"></a>运算符优先级</h2><p>算术运算符优先级大于比较运算符</p><p>比较运算符优先级大于逻辑运算符</p><p>逻辑运算符内部三个优先级 not &gt; and &gt; or</p><p><code>加减乘除 &gt; 比较 &gt; not and or</code>。加括号优先级最高。</p>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>变量</title>
      <link href="/post/13ffbe88.html"/>
      <url>/post/13ffbe88.html</url>
      
        <content type="html"><![CDATA[<h2 id="变量介绍"><a href="#变量介绍" class="headerlink" title="变量介绍"></a>变量介绍</h2><p>程序是用来处理数据的。它可以接收输入数据，对其执行一系列操作，最终生成输出数据。通过使用变量，我们可以在程序中存储和操作数据，以实现所需的功能。</p><p>数据可以被看作是对事物的描述或表示。数据是从真实世界中获取、记录和存储的信息。它可以是数字、文本、图像、声音等形式，用来表示事物。</p><p>在Python中，等号(<code>=</code>)这个符号被用作赋值运算符。赋值是指将一个值赋给一个变量。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将5赋值给变量x，从此以后，x就代表整数5，使用x也就是使用10。</span></span><br><span class="line">x = <span class="number">5</span></span><br></pre></td></tr></table></figure><p>Python中的赋值操作使用等号（<code>=</code>），将右边表达式的结果存储在左边的变量中。这种操作允许我们方便地将计算结果保存到变量中，以便后续使用。</p><p>在编程中，表达式指的是一段代码或语句，用于计算并生成一个值。任何能够生成一个值的代码片段都可以被称为表达式。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y = <span class="number">2</span> + <span class="number">3</span></span><br></pre></td></tr></table></figure><h2 id="变量命名规则"><a href="#变量命名规则" class="headerlink" title="变量命名规则"></a>变量命名规则</h2><p>规则是指明确的、强制性的原则或要求，必须遵守。</p><ul><li><p>Python中变量名由字符、下划线和数字组成，且第一个字符不能是数字。</p></li><li><p>Python中变量名的字母是严格区分大小写的，Age和age是不同的变量。</p></li><li><p>Python中变量名不能和Python中的关键字相同，关键字是Python语言中一些已经被赋予特定意义的单词，这就要求开发者在开发程序时，不能用这些关键字作为变量名。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> keyword</span><br><span class="line"><span class="built_in">print</span>(keyword.kwlist)</span><br></pre></td></tr></table></figure></li></ul><h2 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h2><p>规范是一种约定旨在提供一致性和最佳实践的建议，但不强制要求遵守。</p><ul><li>变量名应该具有描述性，能够清晰地表达变量的用途和含义。</li><li>变量名应该使用小写字母，并使用下划线作为单词之间的分隔符。</li><li>对于常量（不会改变的值），可以使用全大写字母，并使用下划线作为单词之间的分隔符。</li><li>尽量避免使用单个下划线作为变量名，因为它通常用于表示临时或无用的变量。</li><li>变量名应具有描述性，但也要尽量简洁，不要过于冗长。</li></ul><h2 id="数据类型初识"><a href="#数据类型初识" class="headerlink" title="数据类型初识"></a>数据类型初识</h2><p>数据类型是编程语言中用来定义不同种类数据的分类，不同的数据类型具有不同的特征和操作。</p><h3 id="整数类型"><a href="#整数类型" class="headerlink" title="整数类型"></a>整数类型</h3><p>在Python中，整数是一种数据类型，用于表示没有小数部分的数字。整数可以是正数、零或负数。使用<code>type()</code>函数可以检查变量的数据类型。Python 3.6及更高版本支持数字分隔符，允许在数字中使用下划线 <code>_</code> 以提高可读性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义整数</span></span><br><span class="line">number = <span class="number">78</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印整数和其类型</span></span><br><span class="line"><span class="built_in">print</span>(number)</span><br><span class="line"><span class="built_in">print</span>(<span class="built_in">type</span>(number))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用数字分隔符</span></span><br><span class="line">click = <span class="number">1_300_000</span></span><br><span class="line"><span class="built_in">print</span>(click)</span><br></pre></td></tr></table></figure><h3 id="浮点数类型"><a href="#浮点数类型" class="headerlink" title="浮点数类型"></a>浮点数类型</h3><p>浮点数类型用于表示带有小数部分的数字。浮点数由整数部分和小数部分组成，并使用小数点来分隔它们。用来存储人的身高，体重，薪资等小数相关的数据，Python中的小数有两种书写形式。</p><ul><li><p>十进制形式：就是我们平时看到的小数形式，例如 34.6、346.0、0.346。</p></li><li><p>科学计数法：当浮点数非常大或非常小时，可以使用科学计数法来表示。科学计数法使用e或E后跟指数来表示10的幂。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">3.14e2</span>  <span class="comment"># 3.14乘以10的2次方，结果为314.0</span></span><br><span class="line">y = <span class="number">1.23e-3</span>  <span class="comment"># 1.23乘以10的负3次方，结果为0.00123</span></span><br></pre></td></tr></table></figure></li></ul><p>浮点数的精度是有限的，这是由于计算机内部使用二进制表示浮点数，而无法精确表示某些十进制小数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="built_in">print</span>(x)  <span class="comment"># 结果为0.30000000000000004，而不是0.3</span></span><br></pre></td></tr></table></figure><p>在Python中，decimal模块提供了高精度十进制运算的支持。该模块用于进行精确的十进制计算，避免了浮点数运算中可能出现的舍入误差。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> decimal</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建Decimal对象并进行计算</span></span><br><span class="line">num1 = decimal.Decimal(<span class="string">&#x27;0.1&#x27;</span>)</span><br><span class="line">num2 = decimal.Decimal(<span class="string">&#x27;0.2&#x27;</span>)</span><br><span class="line">result = num1 + num2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印结果</span></span><br><span class="line"><span class="built_in">print</span>(result)  <span class="comment"># 输出: 0.3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 舍入操作</span></span><br><span class="line">rounded_sum = result.quantize(decimal.Decimal(<span class="string">&#x27;0.00&#x27;</span>))</span><br><span class="line"><span class="built_in">print</span>(rounded_sum)  <span class="comment"># 输出: 0.30</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>字符串在Python中是一种用于存储文本数据的数据类型，可以包含字母、标点、特殊符号以及全球各种文字。</p><p>在Python中，可以使用单引号（’）、双引号（”）或三引号（’’’ 或 “””）来定义字符串。这些引号之间没有本质的区别，可以根据个人偏好选择使用哪种引号。</p><p>然而，当字符串内容中出现引号时，需要进行特殊处理，以避免引号干扰Python解析字符串的方式。这可以通过在字符串中使用不同类型的引号来实现。</p><p>以下是一些示例，展示了如何处理包含引号的字符串：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用不同类型的引号处理包含引号的字符串</span></span><br><span class="line">str1 = <span class="string">&#x27;She said, &quot;Hello!&quot;&#x27;</span></span><br><span class="line">str2 = <span class="string">&quot;He replied, &#x27;Hi!&#x27;&quot;</span></span><br><span class="line">str3 = <span class="string">&#x27;&#x27;&#x27;They exclaimed, &quot;It&#x27;s amazing!&quot;&#x27;&#x27;&#x27;</span></span><br><span class="line">str4 = <span class="string">&quot;&quot;&quot;I asked, &#x27;What&#x27;s your name?&#x27;&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(str1)  <span class="comment"># 输出: She said, &quot;Hello!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str2)  <span class="comment"># 输出: He replied, &#x27;Hi!&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(str3)  <span class="comment"># 输出: They exclaimed, &quot;It&#x27;s amazing!&quot;</span></span><br><span class="line"><span class="built_in">print</span>(str4)  <span class="comment"># 输出: I asked, &#x27;What&#x27;s your name?&#x27;</span></span><br></pre></td></tr></table></figure><p>转义字符：转义字符是一种特殊的字符序列，用于表示在字符串中具有特殊意义的字符。在Python中，转义字符使用反斜杠（\）作为前缀，后跟特定的字符，以表示特殊含义。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">1. \&#x27;：表示单引号（&#x27;）。</span></span><br><span class="line"><span class="string">2. \&quot;：表示双引号（&quot;）。</span></span><br><span class="line"><span class="string">3. \\：表示反斜杠（\）。</span></span><br><span class="line"><span class="string">4. \n：表示换行符。</span></span><br><span class="line"><span class="string">5. \t：表示制表符。</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">str1 = <span class="string">&#x27;She said, &quot;It\&#x27;s raining!&quot;&#x27;</span></span><br><span class="line">str2 = <span class="string">&quot;He replied, \&quot;That&#x27;s great!\&quot;&quot;</span></span><br><span class="line">str3 = <span class="string">&quot;This is a\nnew line.&quot;</span></span><br><span class="line">str4 = <span class="string">&quot;This is a\ttab.&quot;</span></span><br></pre></td></tr></table></figure><p>原始字符串：在字符串的开头加上<code>r</code>前缀，就变成了原始字符串<code>\</code>不会被当作转义字符，所有的内容都保持“原汁原味”的样子。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用原始字符串</span></span><br><span class="line">path = <span class="string">r&#x27;C:\path\to\file.txt&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(path)  <span class="comment"># 输出: C:\path\to\file.txt</span></span><br></pre></td></tr></table></figure><p>需要注意的是，原始字符串中的最后一个字符如果是反斜杠（\），会导致语法错误。这是因为反斜杠是用来转义字符的，而在原始字符串中，反斜杠不进行转义，这可能导致解释器认为字符串没有正确结束而产生语法错误。</p><p>当<code>+</code>与<code>*</code>用于数字时表示加法和乘法，当 <code>+</code> 和 <code>*</code> 用于字符串时，它们表示字符串的连接和重复。</p><ul><li><p><strong>字符串连接 (<code>+</code>):</strong> 使用 <code>+</code> 运算符可以将两个字符串连接在一起，形成一个新的字符串。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;Hello&quot;</span></span><br><span class="line">str2 = <span class="string">&quot;World&quot;</span></span><br><span class="line">result = str1 + <span class="string">&quot; &quot;</span> + str2</span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li><li><p><strong>字符串重复 (<code>*</code>):</strong> 使用 <code>*</code> 运算符可以将一个字符串重复多次。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">str1 = <span class="string">&quot;abc&quot;</span></span><br><span class="line">result = str1 * <span class="number">3</span></span><br><span class="line"><span class="built_in">print</span>(result)</span><br></pre></td></tr></table></figure></li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>不同的数据类型都有不同的功能，例如：整型可以加减乘除 而 字符串只能加(拼接)和乘法。 如果想要做转换可遵循一个基本规则：想转换什么类型就让他包裹一下。</p><ul><li><code>int(x)</code>：将x转换为整数类型。如果x是浮点数，将截断小数部分。如果x是字符串，必须表示一个整数值。</li><li><code>float(x)</code>：将x转换为浮点数类型。如果x是整数，将转换为相应的浮点数；如果x是字符串，必须表示一个数值。</li><li><code>str(x)</code>：将x转换为字符串类型。x可以是任意数据类型。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>注释与输入输出</title>
      <link href="/post/34e86d5a.html"/>
      <url>/post/34e86d5a.html</url>
      
        <content type="html"><![CDATA[<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2><p>注释是用来在代码中添加说明、解释的文本。注释对于提高代码的可读性、易于理解和维护非常有用。在Python中，有两种常用的注释方式：单行注释和多行注释。</p><h3 id="单行注释"><a href="#单行注释" class="headerlink" title="单行注释"></a>单行注释</h3><p>在Python中，单行注释以 <code>#</code> 开头，用于在代码中添加对特定语句或行的注释。单行注释的内容将在 <code>#</code> 符号后的所有字符，直到行末结束。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 这是一个单行注释</span></span><br><span class="line">x = <span class="number">5</span>  <span class="comment"># 这是给变量x赋值的语句</span></span><br></pre></td></tr></table></figure><h3 id="多行注释"><a href="#多行注释" class="headerlink" title="多行注释"></a>多行注释</h3><p>Python 中没有官方的多行注释语法，但通常使用多行字符串来实现多行注释的效果。多行字符串可以使用单引号 (<code>&#39;&#39;&#39;</code>) 或双引号 (<code>&quot;&quot;&quot;</code>) 包围，而不赋给任何变量。但由于不赋给任何变量，因此不会占用额外的内存。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">这是一个多行注释</span></span><br><span class="line"><span class="string">它可以跨越多行</span></span><br><span class="line"><span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello, World!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">这也是一个多行注释</span></span><br><span class="line"><span class="string">可以使用单引号或双引号</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;Hello again!&quot;</span>)</span><br></pre></td></tr></table></figure><h2 id="输入与输出"><a href="#输入与输出" class="headerlink" title="输入与输出"></a>输入与输出</h2><p>用户可以提供输入数据给程序，程序经过处理后生成输出结果，并将结果返回给用户。</p><h3 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h3><p>在Python中，可以使用input()函数接收用户的输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">input</span>(tipmsg)</span><br></pre></td></tr></table></figure><p><code>input()</code>函数用于接收用户的输入，该函数会等待用户在命令行中输入内容，并将输入内容作为字符串返回。</p><p>tipmsg表示提示信息，它会显示在控制台上，告诉用户应该输入什么样的内容；如果不写tipmsg，就不会有任何提示信息。</p><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><p>在Python中使用print函数，将括号中的内容显示在命令行中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 只输出一个值</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;hello world&#x27;</span>)  </span><br><span class="line"><span class="comment"># 一次性输出多个值，值用逗号隔开</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;first&#x27;</span>,<span class="string">&#x27;second&#x27;</span>,<span class="string">&#x27;third&#x27;</span>)  </span><br></pre></td></tr></table></figure><p>一次性输出多个值默认以空格隔开多个值，如果希望改变默认的分隔符，可通过sep参数进行设置。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(<span class="string">&#x27;first&#x27;</span>, <span class="string">&#x27;second&#x27;</span>, <span class="string">&#x27;third&#x27;</span>, sep=<span class="string">&#x27;|&#x27;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python环境搭建</title>
      <link href="/post/13c36235.html"/>
      <url>/post/13c36235.html</url>
      
        <content type="html"><![CDATA[<p>Python环境搭建指的是在计算机上配置必要的软件，以便能够运行和开发Python代码。</p><h2 id="安装Python解释器"><a href="#安装Python解释器" class="headerlink" title="安装Python解释器"></a>安装Python解释器</h2><p><a href="https://www.python.org/ftp/python/3.8.10/python-3.8.10-amd64.exe"><strong>点击下载Python解释器安装包</strong></a>，双击下载得到的python-3.8.10-amd64.exe，就可以正式开始安装Python解释器了。</p><p><img src="/./img/1.png" alt="Python安装第一步"></p><p>尽量勾选<code>Add Python 3.8 to PATH</code>，这样可以将Python命令工具所在目录添加到系统Path环境变量中，以后开发程序或者运行Python命令会非常方便。</p><p>点击”Customize installation”进行入下一步，选择要安装的Python组件。</p><p><img src="/./img/2.png" alt="Python安装第二步"></p><p>没有特殊要求的话，保持默认即可，也就是全部勾选。点击”Next”继续。</p><p><img src="/./img/3.png" alt="Python安装第三步"></p><p>Install for all users（为所有用户安装）：默认情况下，Python安装程序将Python仅安装到当前用户的目录中。选择此选项可以将Python安装为系统范围内的共享安装，使得所有用户都可以访问和使用Python。</p><p>选择好你的安装目录，点击”Install”，等待几分钟就可以完成安装。</p><p>安装完成以后，打开Windows的命令行程序，在窗口中输入python，如果出现Python的版本信息，并看到命令提示符<code>&gt;&gt;&gt;</code>，就说明安装成功了。</p><p>Python程序的书写与执行方式有以下几种：</p><ul><li><p>打开命令行窗口，输入python启动Python交互式解释器。可以逐行执行Python代码并查看结果。</p></li><li><p>使用任何文本编辑器创建一个以.py为扩展名的Python源代码文件。在文件中编写Python代码，保存文件后，可以通过命令行执行Python解释器来运行程序。<br>  执行方式：打开命令行窗口，导航到保存Python源代码文件的目录，然后运行以下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python 文件名.py</span><br></pre></td></tr></table></figure></li><li><p>使用专门针对Python开发的<strong>集成开发环境（IDE）</strong>，集成开发环境，用来表示辅助程序员开发的应用软件，是它们的一个总称。用来提升程序员的开发效率。  IDE提供了代码编辑、调试、运行等功能，以及更友好的开发环境。</p></li></ul><h2 id="PyCharm安装"><a href="#PyCharm安装" class="headerlink" title="PyCharm安装"></a>PyCharm安装</h2><p><img src="/./img/4.png" alt="pycharm安装第一步"></p><p><img src="/./img/5.png" alt="pycharm安装第二步"></p><p><img src="/./img/6.png" alt="pycharm安装第三步"></p><p><img src="/./img/7.png" alt="pycharm安装第四步"></p><p><strong>显示中文界面。</strong></p><ul><li>点击setting</li><li>点击”plugins”选项。</li><li>输入”Chinese”找到中文安装包，点击”Install”。</li><li>安装完成后，点击”restart IDE”重启程序。</li><li>重启后，软件已经成功变成中文。</li></ul><p><strong>滚轮调整字体大小。</strong></p><ul><li>点击设置</li><li>点击常规</li><li>勾选使用Ctrl+鼠标滚轮更改字号</li></ul><p><strong>任务栏字体大小</strong></p><ul><li>点击设置</li><li>点击外观与行为，点击外观，点击使用自定义字体。</li><li>选择字体大小</li></ul>]]></content>
      
      
      <categories>
          
          <category> Python基础语法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>butterfly主题页面配置</title>
      <link href="/post/aa89b74e.html"/>
      <url>/post/aa89b74e.html</url>
      
        <content type="html"><![CDATA[<h2 id="标签页"><a href="#标签页" class="headerlink" title="标签页"></a>标签页</h2><ul><li>前往你的Hexo博客的根目录</li><li>输入<code>hexo new page tags</code></li><li>你会找到<code>source/tags/index.md</code>这个文件</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 标签</span><br><span class="line">date: 2024-02-05 14:09:59</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">orderby: random</span><br><span class="line"><span class="section">order: 1</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>type</code></td><td align="center">【必须】页面类型，必须为<code>tags</code></td></tr><tr><td align="center"><code>orderby</code></td><td align="center">【可选】排序方式 ：random&#x2F;name&#x2F;length</td></tr><tr><td align="center"><code>order</code></td><td align="center">【可选】排序次序： 1, asc for ascending; -1, desc for descending</td></tr></tbody></table><h2 id="分类页"><a href="#分类页" class="headerlink" title="分类页"></a>分类页</h2><ul><li>前往你的Hexo博客的根目录</li><li>输入<code>hexo new page categories</code></li><li>你会找到<code>source/categories/index.md</code>这个文件</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 分类</span><br><span class="line">date: 2024-02-05 14:15:11</span><br><span class="line"><span class="section">type: &quot;categories&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><h2 id="友情链接"><a href="#友情链接" class="headerlink" title="友情链接"></a>友情链接</h2><ul><li>前往你的Hexo博客的根目录</li><li>输入<code>hexo new page link</code></li><li>你会找到<code>source/link/index.md</code>这个文件</li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 友情链接</span><br><span class="line">date: 2024-02-05 14:19:47</span><br><span class="line"><span class="section">type: &quot;link&quot;</span></span><br><span class="line"><span class="section">---</span></span><br></pre></td></tr></table></figure><p>在Hexo博客目录中的 source&#x2F;_data（如果没有 _data 文件夹，请自行创建），创建一个文件 link.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">友情链接</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">那些人，那些事</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Hexo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://hexo.io/zh-tw/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://d33wubrfki0l68.cloudfront.net/6657ba50e702d84afb32fe846bed54fba1a77add/827ae/logo.svg</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">快速、简单且强大的网志框架</span></span><br><span class="line"></span><br><span class="line"><span class="bullet">-</span> <span class="attr">class_name:</span> <span class="string">网站</span></span><br><span class="line">  <span class="attr">class_desc:</span> <span class="string">值得推荐的网站</span></span><br><span class="line">  <span class="attr">link_list:</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Youtube</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.youtube.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/9ZkGg8v3azHJfM1.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">视频网站</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Weibo</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://www.weibo.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/TLJBum386vcnI1P.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">中国最大社交分享平台</span></span><br><span class="line">    <span class="bullet">-</span> <span class="attr">name:</span> <span class="string">Twitter</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://twitter.com/</span></span><br><span class="line">      <span class="attr">avatar:</span> <span class="string">https://i.loli.net/2020/05/14/5VyHPQqR6LWF39a.png</span></span><br><span class="line">      <span class="attr">descr:</span> <span class="string">社交分享平台</span></span><br></pre></td></tr></table></figure><h2 id="普通的页面"><a href="#普通的页面" class="headerlink" title="普通的页面"></a>普通的页面</h2><p>只需要 hexo new page xxxxx 创建你的页面就行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new page about</span><br></pre></td></tr></table></figure><h2 id="404页面"><a href="#404页面" class="headerlink" title="404页面"></a>404页面</h2><p>_config.butterfly.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># A simple 404 page</span></span><br><span class="line"><span class="attr">error_404:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">subtitle:</span> <span class="string">&quot;页面没有找到&quot;</span></span><br><span class="line">  <span class="attr">background:</span> </span><br></pre></td></tr></table></figure><h2 id="导航栏设置"><a href="#导航栏设置" class="headerlink" title="导航栏设置"></a>导航栏设置</h2><h3 id="参数设置"><a href="#参数设置" class="headerlink" title="参数设置"></a>参数设置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">nav:</span></span><br><span class="line">  <span class="attr">logo:</span> <span class="comment">#image</span></span><br><span class="line">  <span class="attr">display_title:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">fixed:</span> <span class="literal">false</span> <span class="comment"># fixed navigation bar</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">logo</td><td align="center">网站的 logo，支持图片，直接填入图片链接</td></tr><tr><td align="center">display_title</td><td align="center">是否显示网站标题，填写true或者false</td></tr><tr><td align="center">fixed</td><td align="center">是否固定状态栏，填写true或者false</td></tr></tbody></table><h3 id="菜单-x2F-目录"><a href="#菜单-x2F-目录" class="headerlink" title="菜单&#x2F;目录"></a>菜单&#x2F;目录</h3><p>必须是 &#x2F;xxx&#x2F;，后面||分开，然后写图标名。如果不希望显示图标，图标名可不写。默认子目录是展开的，如果你想要隐藏，在子目录里添加hide。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu:</span><br><span class="line">  首页: / || fas fa-home</span><br><span class="line">  时间轴: /archives/ || fas fa-archive</span><br><span class="line">  标签: /tags/ || fas fa-tags</span><br><span class="line">  分类: /categories/ || fas fa-folder-open</span><br><span class="line">  链接||fas fa-list:</span><br><span class="line"><span class="code">    友链: /link/ || fas fa-link</span></span><br><span class="line"><span class="code">    关于: /about/ || fas fa-heart</span></span><br></pre></td></tr></table></figure><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Butterfly支持6种代码高亮样式：darker\pale night\light\ocean\mac\mac light。</p><p>修改主题配置文件_config.butterfly.yml。中的highlight_theme属性。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_theme:</span> <span class="string">mac</span> <span class="string">light</span></span><br></pre></td></tr></table></figure><p>主题支持代码复制功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_copy:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>在默认情况下，代码框自动展开，可设置是否所有代码框都关闭状态，点击&gt;可展开代码</p><ul><li>true 全部代码框不展开，需点击&gt;打开</li><li>false 代码框展开，有&gt;点击按钮</li><li>none 不显示&gt;按钮</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">highlight_shrink:</span> <span class="string">none</span> </span><br></pre></td></tr></table></figure><p>Hexo 在编译的时候不会实现代码自动换行。如果你不希望在代码块的区域里有横向滚动条的话，那么你可以考虑开启这个功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">code_word_wrap:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="主页文章节选"><a href="#主页文章节选" class="headerlink" title="主页文章节选"></a>主页文章节选</h2><p>在butterfly里，有四种可供选择</p><ul><li>description： 只显示description</li><li>both： 优先选择description，如果没有配置description，则显示自动节选的内容</li><li>auto_excerpt：只显示自动节选</li><li>false： 不显示文章内容</li></ul><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Display the article introduction on homepage</span></span><br><span class="line"><span class="comment"># 1: description</span></span><br><span class="line"><span class="comment"># 2: both (if the description exists, it will show description, or show the auto_excerpt)</span></span><br><span class="line"><span class="comment"># 3: auto_excerpt (default)</span></span><br><span class="line"><span class="comment"># false: do not show the article introduction</span></span><br><span class="line"><span class="attr">index_post_content:</span></span><br><span class="line">  <span class="attr">method:</span> <span class="number">3</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">500</span> <span class="comment"># if you set method to 2 or 3, the length need to config</span></span><br></pre></td></tr></table></figure><p>description在front-matter里添加</p><h2 id="顶部图"><a href="#顶部图" class="headerlink" title="顶部图"></a>顶部图</h2><p>如果不要显示顶部图，可直接配置 disable_top_img: true</p><table><thead><tr><th align="center">配置</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">index_img</td><td align="center">主页的 top_img</td></tr><tr><td align="center">default_top_img</td><td align="center">默认的 top_img，当页面的 top_img 没有配置时，会显示 default_top_img</td></tr><tr><td align="center">archive_img</td><td align="center">归档页面的top_img</td></tr><tr><td align="center">tag_img</td><td align="center">tag子页面的默认top_img</td></tr><tr><td align="center">tag_per_img</td><td align="center">tag子页面的top_img，可配置每个tag的 top_img</td></tr><tr><td align="center">category_img</td><td align="center">category子页面的默认top_img</td></tr><tr><td align="center">category_per_img</td><td align="center">category子页面的top_img，可配置每个category 的top_img</td></tr></tbody></table><p>如果是需要本地图片的话，在source目录下创建一个img文件夹</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_top_img:</span> <span class="string">&quot;./img/index.jpg&quot;</span></span><br></pre></td></tr></table></figure><h2 id="文章封面"><a href="#文章封面" class="headerlink" title="文章封面"></a>文章封面</h2><p>文章的markdown文档上,在Front-matter添加cover ,并填上要显示的图片地址。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">cover:</span></span><br><span class="line">  <span class="comment"># 是否显示文章封面</span></span><br><span class="line">  <span class="attr">index_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">aside_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">archives_enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 封面显示的位置</span></span><br><span class="line">  <span class="comment"># 三个值可配置 left , right , both</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">both</span></span><br><span class="line">  <span class="comment"># 当没有设置cover时，默认的封面显示</span></span><br><span class="line">  <span class="attr">default_cover:</span> </span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">参数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">index_enable</td><td align="center">主页是否显示文章封面图</td></tr><tr><td align="center">aside_enable</td><td align="center">侧栏是否显示文章封面图</td></tr><tr><td align="center">archives_enable</td><td align="center">归档页面是否显示文章封面图</td></tr><tr><td align="center">position</td><td align="center">主页卡片文章封面的显示位置<br />left：全部显示在左边<br />right：全部显示在右边<br />both：封面位置以左右左右轮流显示</td></tr><tr><td align="center">default_cover</td><td align="center">默认的 cover, 可配置图片链接&#x2F;顔色&#x2F;渐变色等</td></tr></tbody></table><p>当配置多张图片时,会随机选择一张作为cover.此时写法应为</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">default_cover:</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg2.png</span></span><br><span class="line">  <span class="bullet">-</span> <span class="string">https://jsd.012700.xyz/gh/jerryc127/CDN@latest/cover/default_bg3.png</span></span><br></pre></td></tr></table></figure><h2 id="页面meta显示"><a href="#页面meta显示" class="headerlink" title="页面meta显示"></a>页面meta显示</h2><p>这个选项是用来显示文章的相关信息的。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">page:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 主页文章日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">relative</span> <span class="comment"># date/relative 显示日期还是相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 主页是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 显示描述性文字</span></span><br><span class="line">  <span class="attr">post:</span></span><br><span class="line">    <span class="attr">date_type:</span> <span class="string">both</span> <span class="comment"># created or updated or both 文章页日期是创建日或者更新日或都显示</span></span><br><span class="line">    <span class="attr">date_format:</span> <span class="string">relative</span> <span class="comment"># date/relative 显示日期还是相对日期</span></span><br><span class="line">    <span class="attr">categories:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示分类</span></span><br><span class="line">    <span class="attr">tags:</span> <span class="literal">true</span> <span class="comment"># true or false 文章页是否显示标签</span></span><br><span class="line">    <span class="attr">label:</span> <span class="literal">true</span> <span class="comment"># true or false 显示描述性文字</span></span><br></pre></td></tr></table></figure><h2 id="文章页相关配置"><a href="#文章页相关配置" class="headerlink" title="文章页相关配置"></a>文章页相关配置</h2><h3 id="文章版权"><a href="#文章版权" class="headerlink" title="文章版权"></a>文章版权</h3><p>为你的博客文章展示文章版权和许可协议。</p><p>修改主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">decode:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">author_href:</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span></span><br><span class="line">  <span class="attr">license_url:</span> <span class="string">https://creativecommons.org/licenses/by-nc-sa/4.0/</span></span><br></pre></td></tr></table></figure><p>如果有文章（例如：转载文章）不需要显示版权，可以在文章Front-matter单独设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copyright:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><p>从3.0.0开始，支持对单独文章设置版权信息，可以在文章Front-matter单独设置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">copyright_author:</span> <span class="string">xxxx</span></span><br><span class="line"><span class="attr">copyright_author_href:</span> <span class="string">https://xxxxxx.com</span></span><br><span class="line"><span class="attr">copyright_url:</span> <span class="string">https://xxxxxx.com</span></span><br><span class="line"><span class="attr">copyright_info:</span> <span class="string">此文章版权归xxxxx所有，如有转载，请注明来自原作者</span></span><br></pre></td></tr></table></figure><h2 id="TOC"><a href="#TOC" class="headerlink" title="TOC"></a>TOC</h2><p>TOC通常指的是”Table of Contents”，即目录。在不同的上下文中，TOC可以指代不同的内容，例如文档、文章、网页等中的目录。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">post:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">page:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">expand:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">style_simple:</span> <span class="literal">false</span> <span class="comment"># for post</span></span><br><span class="line">  <span class="attr">scroll_percent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">属性</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center">post</td><td align="center">文章页是否显示 TOC</td></tr><tr><td align="center">page</td><td align="center">普通页面是否显示 TOC</td></tr><tr><td align="center">number</td><td align="center">是否显示章节数</td></tr><tr><td align="center">expand</td><td align="center">是否展开 TOC</td></tr><tr><td align="center">style_simple</td><td align="center">简洁模式（侧边栏只显示 TOC, 只对文章页有效 ）</td></tr><tr><td align="center">scroll_percent</td><td align="center">是否显示滚动进度百分比</td></tr></tbody></table><h2 id="相关文章"><a href="#相关文章" class="headerlink" title="相关文章"></a>相关文章</h2><p>相关文章推荐的原理是根据文章tags的比重来推荐</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">related_post:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">6</span> <span class="comment"># 显示推荐文章数目</span></span><br><span class="line">  <span class="attr">date_type:</span> <span class="string">created</span> <span class="comment"># or created or updated 文章日期显示创建日或者更新日</span></span><br></pre></td></tr></table></figure><h2 id="页面锚点"><a href="#页面锚点" class="headerlink" title="页面锚点"></a>页面锚点</h2><p>开启页面锚点后，当你在进行滚动时，页面链接会根据标题ID进行替换</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># anchor</span></span><br><span class="line"><span class="attr">anchor:</span></span><br><span class="line">  <span class="comment"># when you scroll, the URL will update according to header id.</span></span><br><span class="line">  <span class="attr">auto_update:</span> <span class="literal">false</span></span><br><span class="line">  <span class="comment"># Click the headline to scroll and update the anchor</span></span><br><span class="line">  <span class="attr">click_to_scroll:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="文章分页按钮"><a href="#文章分页按钮" class="headerlink" title="文章分页按钮"></a>文章分页按钮</h2><p>可设置分页的逻辑，也可以关闭分页显示。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># post_pagination (分页)</span></span><br><span class="line"><span class="comment"># value: 1 || 2 || false</span></span><br><span class="line"><span class="comment"># 1: The &#x27;next post&#x27; will link to old post</span></span><br><span class="line"><span class="comment"># 2: The &#x27;next post&#x27; will link to new post</span></span><br><span class="line"><span class="comment"># false: disable pagination</span></span><br><span class="line"><span class="attr">post_pagination:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure><h2 id="头像"><a href="#头像" class="headerlink" title="头像"></a>头像</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">avatar:</span></span><br><span class="line">  <span class="attr">img:</span> <span class="string">&quot;./img/avatar.jpg&quot;</span></span><br><span class="line">  <span class="attr">effect:</span> <span class="literal">false</span>  <span class="comment"># 头像会一直转圈</span></span><br></pre></td></tr></table></figure><h2 id="Footer-设置"><a href="#Footer-设置" class="headerlink" title="Footer 设置"></a>Footer 设置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">owner:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">since:</span> <span class="number">2024</span></span><br><span class="line">  <span class="attr">custom_text:</span> <span class="string">Hi,</span> <span class="string">welcome</span> <span class="string">to</span> <span class="string">my</span> <span class="string">blog!</span></span><br><span class="line">  <span class="attr">copyright:</span> <span class="literal">false</span> <span class="comment"># Copyright of theme and framework</span></span><br></pre></td></tr></table></figure><h2 id="右下角按钮"><a href="#右下角按钮" class="headerlink" title="右下角按钮"></a>右下角按钮</h2><p>閲读模式下会去掉除文章外的内容，避免干扰閲读。只会出现在文章页面，右下角会有閲读模式按钮。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">readmode:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>滚动状态百分比</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># show scroll percent in scroll-to-top button</span></span><br><span class="line"><span class="attr">rightside_scroll_percent:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><h2 id="侧边栏设置"><a href="#侧边栏设置" class="headerlink" title="侧边栏设置"></a>侧边栏设置</h2><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">aside:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">hide:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">button:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">mobile:</span> <span class="literal">true</span> <span class="comment"># display on mobile</span></span><br><span class="line">  <span class="attr">position:</span> <span class="string">right</span> <span class="comment"># left or right</span></span><br><span class="line">  <span class="attr">display:</span></span><br><span class="line">    <span class="attr">archive:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">tag:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">category:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">card_author:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">description:</span></span><br><span class="line">    <span class="attr">button:</span></span><br><span class="line">      <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">      <span class="attr">icon:</span> <span class="string">fab</span> <span class="string">fa-github</span></span><br><span class="line">      <span class="attr">text:</span> <span class="string">Follow</span> <span class="string">Me</span></span><br><span class="line">      <span class="attr">link:</span> <span class="string">https://github.com/xxxxxx</span></span><br><span class="line">  <span class="attr">card_announcement:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">content:</span> <span class="string">This</span> <span class="string">is</span> <span class="string">my</span> <span class="string">Blog</span></span><br><span class="line">  <span class="attr">card_recent_post:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">5</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort:</span> <span class="string">date</span> <span class="comment"># date or updated</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_categories:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">expand:</span> <span class="string">none</span> <span class="comment"># none/true/false</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_tags:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">40</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">color:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">orderby:</span> <span class="string">random</span> <span class="comment"># Order of tags, random/name/length</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_archives:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">type:</span> <span class="string">monthly</span> <span class="comment"># yearly or monthly</span></span><br><span class="line">    <span class="attr">format:</span> <span class="string">MMMM</span> <span class="string">YYYY</span> <span class="comment"># eg: YYYY年MM月</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br><span class="line">    <span class="attr">limit:</span> <span class="number">8</span> <span class="comment"># if set 0 will show all</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_webinfo:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">post_count:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">last_push_date:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">sort_order:</span> <span class="comment"># Don&#x27;t modify the setting unless you know how it works</span></span><br><span class="line">  <span class="attr">card_post_series:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">orderBy:</span> <span class="string">&#x27;date&#x27;</span> <span class="comment"># Order by title or date</span></span><br><span class="line">    <span class="attr">order:</span> <span class="number">-1</span> <span class="comment"># Sort of order. 1, asc for ascending; -1, desc for descending</span></span><br></pre></td></tr></table></figure><h2 id="搜索"><a href="#搜索" class="headerlink" title="搜索"></a>搜索</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-search --save</span><br></pre></td></tr></table></figure><p>在主题配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">local_search:</span></span><br><span class="line">  <span class="comment"># 是否开启本地搜索</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="comment"># 预加载，开启后，进入网页后会自动加载搜索文件。关闭时，只有点击搜索按钮后，才会加载搜索文件</span></span><br><span class="line">  <span class="attr">preload:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">CDN:</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hexo cl &amp;&amp; hexo generate</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo环境搭建</title>
      <link href="/post/7d922bf5.html"/>
      <url>/post/7d922bf5.html</url>
      
        <content type="html"><![CDATA[<h2 id="Hexo介绍"><a href="#Hexo介绍" class="headerlink" title="Hexo介绍"></a>Hexo介绍</h2><p>Hexo是一个用于创建静态博客网站的开源框架。它基于Node.js构建，提供了简单而强大的工具，使用户能够方便地创建和维护自己的博客。以下是Hexo的一些主要特点和介绍：</p><ul><li><p><strong>静态网站生成器：</strong> Hexo是一个静态网站生成器，它将Markdown文件转换为HTML页面，这样你的博客可以以纯静态文件的形式存储和发布。这有助于提高网站的性能和安全性。</p></li><li><p><strong>Markdown支持：</strong> Hexo使用Markdown语法编写文章，这是一种轻量级的标记语言，使得撰写和编辑内容变得简单和直观。</p></li><li><p><strong>快速部署：</strong> Hexo提供了简单的命令行工具，可以轻松地将你的博客部署到各种托管服务上。</p></li><li><p><strong>主题和插件：</strong> Hexo支持丰富的主题和插件，允许用户定制和美化博客的外观与功能。</p></li><li><p><strong>标签和分类：</strong> Hexo支持标签和分类，使得组织和浏览内容变得更加容易。</p></li><li><p><strong>本地开发服务器：</strong> Hexo提供了一个本地开发服务器，可以在本地预览博客的外观和功能，以便及时调整和修改。</p></li></ul><p>使用Hexo搭建博客的一般步骤包括安装Hexo、选择主题、编写文章、生成静态文件和部署到托管服务。总体而言，Hexo是一个方便、灵活且易于使用的博客框架，适合个人博客和小型网站的建设。</p><h2 id="安装Node"><a href="#安装Node" class="headerlink" title="安装Node"></a>安装Node</h2><ul><li><p>打开Node官网，下载和自己系统相配的Node的安装程序，否则会出现安装问题。<br>  下载地址：<a href="https://nodejs.org/en/download/">https://nodejs.org/en/download/</a></p></li><li><p>下载后傻瓜式安装即可，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;nodejs&#x2F;】，也可以自定义路径。</p></li><li><p>修改npm源：打开CMD窗口，运行如下命令：</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config <span class="built_in">set</span> registry https://registry.npm.taobao.org</span><br></pre></td></tr></table></figure></li></ul><h2 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h2><p>打开CMD窗口，输入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure><p>安装完后输入hexo -v验证是否安装成功。</p><h2 id="注册GitHub帐号"><a href="#注册GitHub帐号" class="headerlink" title="注册GitHub帐号"></a>注册GitHub帐号</h2><ul><li>进入官网 <a href="https://github.com/">https://github.com/</a></li><li>点击右上角的Sign up(注册)。</li><li>填写自己的邮箱、密码、用户名等信息，然后用邮箱验证即可完成。</li></ul><h2 id="创建GitHub仓库"><a href="#创建GitHub仓库" class="headerlink" title="创建GitHub仓库"></a>创建GitHub仓库</h2><ul><li>点击右上角的+按钮，选择New repository，创建一个&lt;用户名&gt;.github.io的仓库。</li><li>找不到创建入口的，访问：<a href="https://github.com/new">https://github.com/new</a></li><li>仓库的格式<strong>必须为</strong>：&lt;用户名&gt;.github.io</li><li>Description：为描述仓库（选填）</li><li>勾选Initialize this repository with初始化一个 README.md 文件</li><li>点击Creat repository进行创建</li></ul><h2 id="Git安装-amp-amp-连接Github"><a href="#Git安装-amp-amp-连接Github" class="headerlink" title="Git安装&amp;&amp;连接Github"></a>Git安装&amp;&amp;连接Github</h2><ul><li><p>进入官网：<a href="https://git-scm.com/downloads">https://git-scm.com/downloads</a> </p></li><li><p>下载后傻瓜式安装Git即可，安装的目录可以使用默认目录【C:&#x2F;Program Files&#x2F;Git】，也可以自定义路径。</p></li><li><p>点击电脑左下角开始即可看见Git Bash。</p></li><li><p>配置用户名和邮箱</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;你的用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure></li><li><p>生成ssh公钥</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;你的邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>  之后打开C盘下用户文件夹下的.ssh的文件夹，会看到 id_rsa.pub</p></li><li><p>用记事本打开公钥（id_rsa.pub），复制里面的内容，然后开始在github中配置ssh密钥。</p></li><li><p>进入github，点击右上角头像 选择settings。</p></li><li><p>进入设置页后选择 SSH and GPG keys</p></li><li><p>测试连接</p>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure></li></ul><h2 id="使用butterfly主题创建博客"><a href="#使用butterfly主题创建博客" class="headerlink" title="使用butterfly主题创建博客"></a>使用butterfly主题创建博客</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-butterfly-cli -g</span><br></pre></td></tr></table></figure><p>找到你需要创建博客的文件夹，初始化创建博客。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">butterfly-cli init &lt;projectName&gt; </span><br></pre></td></tr></table></figure><p>选择第二个模式</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> myBlog</span><br><span class="line">npm install</span><br><span class="line">hexo s</span><br></pre></td></tr></table></figure><h2 id="部署到GitHub"><a href="#部署到GitHub" class="headerlink" title="部署到GitHub"></a>部署到GitHub</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># _config.yml</span></span><br><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">&#x27;git&#x27;</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:ZhanTengYun19930607/ZhanTengYun19930607.github.io</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">main</span></span><br></pre></td></tr></table></figure><p>修改好配置后，运行如下命令，将代码部署到 GitHub</p><p>点击设置-GitHub Pages</p><h2 id="Hexo常用命令"><a href="#Hexo常用命令" class="headerlink" title="Hexo常用命令"></a>Hexo常用命令</h2><ul><li><strong>初始化博客：</strong><code>hexo init &lt;folder&gt;</code>创建一个新的Hexo博客，将文件放置在指定的文件夹中。</li><li><strong>安装依赖</strong>：<code>npm install</code>在Hexo博客目录中运行此命令，安装博客所需的依赖包。</li><li><strong>启动本地服务器：</strong><code>hexo server</code>启动本地开发服务器，用于预览博客。在浏览器中访问 <a href="http://localhost:4000/">http://localhost:4000/</a> 查看效果。</li><li><strong>创建新文章：</strong><code>hexo new &lt;title&gt;</code>创建一篇新文章，<code>&lt;title&gt;</code>是文章的标题。生成的Markdown文件将位于<code>source/_posts/</code>目录下。</li><li><strong>生成静态文件：</strong><code>hexo generate</code>将Markdown文件转换为HTML页面，并生成静态文件。</li><li><strong>清理缓存：</strong><code>hexo clean</code>清理Hexo生成的缓存文件。</li><li><strong>部署博客：</strong><code>hexo deploy</code>部署博客到托管服务。具体的部署配置在 <code>_config.yml</code> 文件中。</li><li><strong>生成并部署博客（合并操作）：</strong><code>hexo clean &amp;&amp; hexo generate &amp;&amp; hexo deploy</code></li></ul><h2 id="网站资料"><a href="#网站资料" class="headerlink" title="网站资料"></a>网站资料</h2><p>站点配置文件<code>_config.yml</code></p><table><thead><tr><th align="center">参数</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center"><code>title</code></td><td align="center">网站标题</td></tr><tr><td align="center"><code>subtitle</code></td><td align="center">网站副标题</td></tr><tr><td align="center"><code>description</code></td><td align="center">网站描述</td></tr><tr><td align="center"><code>keywords</code></td><td align="center">网站的关键词。支持多个关键词。</td></tr><tr><td align="center"><code>author</code></td><td align="center">您的名字</td></tr><tr><td align="center"><code>language</code></td><td align="center">网站使用的语言。对于简体中文用户来说，使用不同的主题可能需要设置成不同的值，请参考你的主题的文档自行设置，常见的有 <code>zh-Hans</code>和 <code>zh-CN</code>。</td></tr><tr><td align="center"><code>timezone</code></td><td align="center">网站时区。Hexo 默认使用您电脑的时区。请参考 <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones">时区列表</a> 进行设置，如 <code>America/New_York</code>, <code>Japan</code>, 和 <code>UTC</code> 。一般的，对于中国大陆地区可以使用 <code>Asia/Shanghai</code>。</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
